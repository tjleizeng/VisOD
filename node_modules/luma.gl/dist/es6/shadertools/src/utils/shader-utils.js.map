{"version":3,"sources":["../../../../../src/shadertools/src/utils/shader-utils.js"],"names":["assert","FS100","FS300","getQualifierDetails","line","qualifiers","Array","isArray","words","replace","split","qualifier","type","definition","includes","name","getPassthroughFS","version","input","inputType","output","outputValue","convertToVec4","typeToChannelSuffix","typeToChannelCount","variable"],"mappings":";AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,MAAMC,KAAK,GAAG,gBAAd;AACA,MAAMC,KAAK,GAAI,oBAAmBD,KAAM,EAAxC,C,CAEA;;AACA,OAAO,SAASE,mBAAT,CAA6BC,IAA7B,EAAmCC,UAAnC,EAA+C;AACpDA,EAAAA,UAAU,GAAGC,KAAK,CAACC,OAAN,CAAcF,UAAd,IAA4BA,UAA5B,GAAyC,CAACA,UAAD,CAAtD;AACA,QAAMG,KAAK,GAAGJ,IAAI,CAACK,OAAL,CAAa,MAAb,EAAqB,EAArB,EAAyBC,KAAzB,CAA+B,KAA/B,CAAd,CAFoD,CAGpD;;AAHoD,gCAIdF,KAJc;AAAA,QAI7CG,SAJ6C;AAAA,QAIlCC,IAJkC;AAAA,QAI5BC,UAJ4B;;AAKpD,MAAI,CAACR,UAAU,CAACS,QAAX,CAAoBH,SAApB,CAAD,IAAmC,CAACC,IAApC,IAA4C,CAACC,UAAjD,EAA6D;AAC3D,WAAO,IAAP;AACD;;AACD,QAAME,IAAI,GAAGF,UAAU,CAACH,KAAX,CAAiB,GAAjB,EAAsB,CAAtB,CAAb;AACA,SAAO;AAACC,IAAAA,SAAD;AAAYC,IAAAA,IAAZ;AAAkBG,IAAAA;AAAlB,GAAP;AACD,C,CAED;AACA;;AACA,OAAO,SAASC,gBAAT,CAA0B;AAACC,EAAAA,OAAO,GAAG,GAAX;AAAgBC,EAAAA,KAAhB;AAAuBC,EAAAA,SAAvB;AAAkCC,EAAAA;AAAlC,IAA4C,EAAtE,EAA0E;AAC/E,MAAI,CAACF,KAAL,EAAY;AACV,WAAOD,OAAO,KAAK,GAAZ,GAAkBf,KAAlB,GAA0BD,KAAjC;AACD;;AACD,QAAMoB,WAAW,GAAGC,aAAa,CAACJ,KAAD,EAAQC,SAAR,CAAjC;;AACA,MAAIF,OAAO,KAAK,GAAhB,EAAqB;AACnB,WAAQ;;KAEPE,SAAU,IAAGD,KAAM;WACbE,MAAO;;IAEdA,MAAO,MAAKC,WAAY;EALxB;AAOD,GAb8E,CAc/E;;;AACA,SAAQ;UACAF,SAAU,IAAGD,KAAM;;mBAEVG,WAAY;EAH7B;AAKD,C,CAED;;AACA,OAAO,SAASE,mBAAT,CAA6BX,IAA7B,EAAmC;AACxC,UAAQA,IAAR;AACE,SAAK,OAAL;AACE,aAAO,GAAP;;AACF,SAAK,MAAL;AACE,aAAO,IAAP;;AACF,SAAK,MAAL;AACE,aAAO,KAAP;;AACF,SAAK,MAAL;AACE,aAAO,MAAP;;AACF;AACEZ,MAAAA,MAAM,CAAC,KAAD,CAAN;AACA,aAAO,IAAP;AAXJ;AAaD,C,CAED;;AACA,OAAO,SAASwB,kBAAT,CAA4BZ,IAA5B,EAAkC;AACvC,UAAQA,IAAR;AACE,SAAK,OAAL;AACE,aAAO,CAAP;;AACF,SAAK,MAAL;AACE,aAAO,CAAP;;AACF,SAAK,MAAL;AACE,aAAO,CAAP;;AACF,SAAK,MAAL;AACE,aAAO,CAAP;;AACF;AACEZ,MAAAA,MAAM,CAAC,KAAD,CAAN;AACA,aAAO,IAAP;AAXJ;AAaD,C,CAED;;AACA,OAAO,SAASsB,aAAT,CAAuBG,QAAvB,EAAiCb,IAAjC,EAAuC;AAC5C,UAAQA,IAAR;AACE,SAAK,OAAL;AACE,aAAQ,QAAOa,QAAS,kBAAxB;;AACF,SAAK,MAAL;AACE,aAAQ,QAAOA,QAAS,aAAxB;;AACF,SAAK,MAAL;AACE,aAAQ,QAAOA,QAAS,QAAxB;;AACF,SAAK,MAAL;AACE,aAAOA,QAAP;;AACF;AACEzB,MAAAA,MAAM,CAAC,KAAD,CAAN;AACA,aAAO,IAAP;AAXJ;AAaD","sourcesContent":["import assert from 'assert';\nconst FS100 = 'void main() {}';\nconst FS300 = `#version 300 es\\n${FS100}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS({version = 100, input, inputType, output} = {}) {\n  if (!input) {\n    return version === 300 ? FS300 : FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version === 300) {\n    return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // version 100\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n"],"file":"shader-utils.js"}
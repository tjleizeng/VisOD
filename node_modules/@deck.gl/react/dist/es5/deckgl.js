"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _core = require("@deck.gl/core");

var _extractJsxLayers = _interopRequireDefault(require("./utils/extract-jsx-layers"));

var _inheritsFrom = require("./utils/inherits-from");

var _evaluateChildren = _interopRequireDefault(require("./utils/evaluate-children"));

var _autobind = _interopRequireDefault(require("./utils/autobind"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var propTypes = _core.Deck.getPropTypes(_propTypes.default);

var defaultProps = _core.Deck.defaultProps;

var DeckGL =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(DeckGL, _React$PureComponent);

  function DeckGL(props) {
    var _this;

    _classCallCheck(this, DeckGL);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeckGL).call(this, props));
    _this.state = {
      width: 0,
      height: 0,
      viewState: props.initialViewState
    };
    _this.children = [];
    (0, _autobind.default)(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(DeckGL, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Allows a subclass of Deck to be used
      // TODO - update propTypes / defaultProps?
      var DeckClass = this.props.Deck || _core.Deck; // DEVTOOLS can cause this to be called twice

      this.deck = this.deck || new DeckClass(Object.assign({}, this.props, {
        initialViewState: null,
        canvas: this.deckCanvas,
        viewState: this._getViewState(this.props),
        // Note: If Deck event handling change size or view state, it calls onResize to update
        onViewStateChange: this._onViewStateChange,
        onResize: this._onResize
      }));
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.deck.finalize();
    } // Public API

  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === void 0 ? null : _ref$layerIds;
      return this.deck.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds
      });
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? 10 : _ref2$depth;
      return this.deck.pickMultipleObjects({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        depth: depth
      });
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? 1 : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? 1 : _ref3$height,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds;
      return this.deck.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds
      });
    }
  }, {
    key: "queryObject",
    value: function queryObject(opts) {
      _core.log.removed('queryObject', 'pickObject')();
    }
  }, {
    key: "queryVisibleObjects",
    value: function queryVisibleObjects(opts) {
      _core.log.removed('queryVisibleObjects', 'pickObjects')();
    } // Callbacks
    // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onResize",
    value: function _onResize(params) {
      this.setState(params);
      this.props.onResize(params);
    } // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(params) {
      // Let app know that view state is changing, and give it a chance to change it
      var viewState = this.props.onViewStateChange(params) || params.viewState; // If initialViewState was set on creation, auto track position

      if (this.state.viewState) {
        this.setState({
          viewState: Object.assign({}, this.state.viewState, _defineProperty({}, params.viewId, viewState))
        });
      }
    } // Private Helpers
    // 1. Extract any JSX layers from the react children
    // 2. Handle any backwards compatiblity props for React layer
    // Needs to be called both from initial mount, and when new props arrive

  }, {
    key: "_updateFromProps",
    value: function _updateFromProps(nextProps) {
      if (!this.deck) {
        return;
      }

      if (nextProps.viewports || nextProps.viewport) {
        _core.log.removed('DeckGL.viewport(s)', 'DeckGL.views')();
      } // extract any deck.gl layers masquerading as react elements from props.children


      var _extractJSXLayers = (0, _extractJsxLayers.default)(nextProps),
          layers = _extractJSXLayers.layers,
          views = _extractJSXLayers.views,
          children = _extractJSXLayers.children;

      var deckProps = Object.assign({}, nextProps, {
        onViewStateChange: this._onViewStateChange,
        onResize: this._onResize,
        layers: layers,
        views: views
      });

      var viewState = this._getViewState(nextProps);

      if (viewState) {
        deckProps.viewState = viewState;
      }

      this.deck.setProps(deckProps);
      this.children = children;
    } // Supports old "geospatial view state as separate props" style (React only!)

  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      if (!props.viewState && 'latitude' in props && 'longitude' in props && 'zoom' in props) {
        if ('maxZoom' in props || 'minZoom' in props) {
          _core.log.removed('maxZoom/minZoom', 'viewState');
        }

        var latitude = props.latitude,
            longitude = props.longitude,
            zoom = props.zoom,
            _props$pitch = props.pitch,
            pitch = _props$pitch === void 0 ? 0 : _props$pitch,
            _props$bearing = props.bearing,
            bearing = _props$bearing === void 0 ? 0 : _props$bearing;
        return {
          latitude: latitude,
          longitude: longitude,
          zoom: zoom,
          pitch: pitch,
          bearing: bearing
        };
      }

      return props.viewState || this.state.viewState;
    } // Iterate over views and reposition children associated with views
    // TODO - Can we supply a similar function for the non-React case?

  }, {
    key: "_positionChildrenUnderViews",
    value: function _positionChildrenUnderViews(children) {
      var _ref4 = this.deck || {},
          viewManager = _ref4.viewManager;

      if (!viewManager || !viewManager.views.length) {
        return [];
      }

      var defaultViewId = viewManager.views[0].id;
      return children.map(function (child, i) {
        if (child.props.viewportId) {
          _core.log.removed('viewportId', '<View>')();
        }

        if (child.props.viewId) {
          _core.log.removed('viewId', '<View>')();
        } // Unless child is a View, position / render as part of the default view


        var viewId = defaultViewId;
        var viewChildren = child;

        if ((0, _inheritsFrom.inheritsFrom)(child.type, _core.View)) {
          viewId = child.props.id || defaultViewId;
          viewChildren = child.props.children;
        }

        var viewport = viewManager.getViewport(viewId);
        var viewState = viewManager.getViewState(viewId); // Drop (auto-hide) elements with viewId that are not matched by any current view

        if (!viewport) {
          return null;
        } // Resolve potentially relative dimensions using the deck.gl container size


        var x = viewport.x,
            y = viewport.y,
            width = viewport.width,
            height = viewport.height;
        viewChildren = (0, _evaluateChildren.default)(viewChildren, {
          x: x,
          y: y,
          width: width,
          height: height,
          viewport: viewport,
          viewState: viewState
        });
        var style = {
          position: 'absolute',
          left: x,
          top: y,
          width: width,
          height: height
        };
        var key = "view-child-".concat(viewId, "-").concat(i);
        return (0, _react.createElement)('div', {
          key: key,
          id: key,
          style: style
        }, viewChildren);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      // TODO - expensive to update on every render?
      this._updateFromProps(this.props); // Render the background elements (typically react-map-gl instances)
      // using the view descriptors


      var children = this._positionChildrenUnderViews(this.children); // TODO - this styling is enforced for correct positioning with children
      // It can override the styling set by `Deck`, this should be consolidated.
      // Note that width and height are handled by deck.gl


      var style = Object.assign({}, {
        position: 'absolute',
        left: 0,
        top: 0
      }, this.props.style);
      var canvas = (0, _react.createElement)('canvas', {
        ref: function ref(c) {
          return _this2.deckCanvas = c;
        },
        key: 'deck-canvas',
        id: this.props.id,
        style: style
      }); // Render deck.gl as last child

      children.push(canvas);
      return (0, _react.createElement)('div', {
        id: 'deckgl-wrapper'
      }, children);
    }
  }]);

  return DeckGL;
}(_react.default.PureComponent);

exports.default = DeckGL;
DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=deckgl.js.map
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { fillArray } from './flatten';

var TypedArrayManager =
/*#__PURE__*/
function () {
  function TypedArrayManager() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$overAlloc = _ref.overAlloc,
        overAlloc = _ref$overAlloc === void 0 ? 1 : _ref$overAlloc;

    _classCallCheck(this, TypedArrayManager);

    this.overAlloc = overAlloc;
  }

  _createClass(TypedArrayManager, [{
    key: "allocate",
    value: function allocate(typedArray, count, _ref2) {
      var size = _ref2.size,
          type = _ref2.type,
          _ref2$copy = _ref2.copy,
          copy = _ref2$copy === void 0 ? false : _ref2$copy;
      var newSize = count * size;

      if (typedArray && newSize <= typedArray.length) {
        return typedArray;
      } // Allocate at least one element to ensure a valid buffer


      var allocSize = Math.max(Math.ceil(newSize * this.overAlloc), 1);

      var newArray = this._allocate(type, allocSize);

      if (typedArray && copy) {
        newArray.set(typedArray);
      }

      this._release(typedArray);

      return newArray;
    }
  }, {
    key: "_allocate",
    value: function _allocate() {
      var Type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Float32Array;
      var size = arguments.length > 1 ? arguments[1] : undefined;

      if (Type === Uint16Array && size > 65535) {
        throw new Error('Vertex count exceeds browser index limit');
      } // TODO - check if available in pool


      return new Type(size);
    }
  }, {
    key: "_release",
    value: function _release(typedArray) {// TODO - add to pool
      // logFunctions.onUpdate({
      //   level: LOG_DETAIL_PRIORITY,
      //   message: `${attributeName} allocated ${allocCount}`,
      //   id: this.id
      // });
    }
  }]);

  return TypedArrayManager;
}();

var Tesselator =
/*#__PURE__*/
function () {
  function Tesselator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Tesselator);

    var _opts$attributes = opts.attributes,
        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;
    this.typedArrayManager = new TypedArrayManager();
    this.indexLayout = null;
    this.bufferLayout = null;
    this.vertexCount = 0;
    this.instanceCount = 0;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.updateGeometry(opts);
    Object.seal(this);
  }
  /* Public methods */


  _createClass(Tesselator, [{
    key: "updateGeometry",
    value: function updateGeometry(_ref3) {
      var data = _ref3.data,
          getGeometry = _ref3.getGeometry,
          positionFormat = _ref3.positionFormat,
          fp64 = _ref3.fp64;
      this.data = data;
      this.getGeometry = getGeometry;
      this.fp64 = fp64;
      this.positionSize = positionFormat === 'XY' ? 2 : 3;

      this._rebuildGeometry();
    }
  }, {
    key: "updatePartialGeometry",
    value: function updatePartialGeometry(_ref4) {
      var start = _ref4.start,
          count = _ref4.count,
          objects = _ref4.objects;
    } // TODO

    /* Subclass interface */
    // Update the positions of a single geometry

  }, {
    key: "updateGeometryAttributes",
    value: function updateGeometryAttributes(geometry, startIndex, size) {
      throw new Error('Not implemented');
    } // Returns the number of vertices in a geometry

  }, {
    key: "getGeometrySize",
    value: function getGeometrySize(geometry) {
      throw new Error('Not implemented');
    }
    /* Private utility methods */

    /**
     * Visit all objects
     * `data` is expected to be an iterable consistent with the base Layer expectation
     */

  }, {
    key: "_forEachGeometry",
    value: function _forEachGeometry(visitor) {
      var data = this.data,
          getGeometry = this.getGeometry;
      var dataIndex = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          var geometry = getGeometry(object);
          visitor(geometry, dataIndex++);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(_ref5) {
      var target = _ref5.target,
          size = _ref5.size,
          getValue = _ref5.getValue;
      var data = this.data,
          bufferLayout = this.bufferLayout;
      var i = 0;
      var dataIndex = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;
          var value = getValue(object, dataIndex);
          var numVertices = bufferLayout[dataIndex++];
          fillArray({
            target: target,
            source: value,
            start: i,
            count: numVertices
          });
          i += numVertices * size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return target;
    }
  }, {
    key: "_rebuildGeometry",
    value: function _rebuildGeometry() {
      var _this = this;

      if (!this.data || !this.getGeometry) {
        return;
      } // count instances


      var indexLayout = [];
      var bufferLayout = [];
      var instanceCount = 0;

      this._forEachGeometry(function (geometry, dataIndex) {
        var count = _this.getGeometrySize(geometry);

        instanceCount += count;
        bufferLayout[dataIndex] = count;
      }); // allocate attributes


      var attributes = this.attributes,
          _attributeDefs = this._attributeDefs,
          typedArrayManager = this.typedArrayManager,
          fp64 = this.fp64;

      for (var name in _attributeDefs) {
        var def = _attributeDefs[name]; // do not create fp64-only attributes unless in fp64 mode

        if (!def.fp64Only || fp64) {
          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
        }
      }

      this.indexLayout = indexLayout;
      this.bufferLayout = bufferLayout;
      this.instanceCount = instanceCount;
      var context = {
        vertexStart: 0,
        indexStart: 0
      };

      this._forEachGeometry(function (geometry, dataIndex) {
        var geometrySize = bufferLayout[dataIndex];
        context.geometryIndex = dataIndex;
        context.geometrySize = geometrySize;

        _this.updateGeometryAttributes(geometry, context);

        context.vertexStart += geometrySize;
        context.indexStart += indexLayout[dataIndex] || 0;
      });

      this.vertexCount = context.indexStart;
    }
  }]);

  return Tesselator;
}();

export { Tesselator as default };
//# sourceMappingURL=tesselator.js.map
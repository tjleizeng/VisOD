function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

import Controller from './controller';
import ViewState from './view-state';
import { Vector2, clamp } from 'math.gl';
var MOVEMENT_SPEED = 10; // per keyboard click

var DEFAULT_STATE = {
  zoom: 0,
  offset: [0, 0],
  minZoom: -10,
  maxZoom: 10
};

var zoom2Scale = function zoom2Scale(zoom) {
  return Math.pow(2, zoom);
};

var OrthographicState =
/*#__PURE__*/
function (_ViewState) {
  _inherits(OrthographicState, _ViewState);

  function OrthographicState(_ref) {
    var _this;

    var width = _ref.width,
        height = _ref.height,
        _ref$offset = _ref.offset,
        offset = _ref$offset === void 0 ? DEFAULT_STATE.offset : _ref$offset,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === void 0 ? DEFAULT_STATE.zoom : _ref$zoom,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === void 0 ? DEFAULT_STATE.minZoom : _ref$minZoom,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === void 0 ? DEFAULT_STATE.maxZoom : _ref$maxZoom,
        startPanPosition = _ref.startPanPosition,
        startPanOffset = _ref.startPanOffset,
        startZoomPosition = _ref.startZoomPosition,
        startZoom = _ref.startZoom;

    _classCallCheck(this, OrthographicState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(OrthographicState).call(this, {
      width: width,
      height: height,
      offset: offset,
      zoom: zoom,
      minZoom: minZoom,
      maxZoom: maxZoom
    }));
    _this._interactiveState = {
      startPanPosition: startPanPosition,
      startPanOffset: startPanOffset,
      startZoomPosition: startZoomPosition,
      startZoom: startZoom
    };
    return _this;
  }
  /* Public API */


  _createClass(OrthographicState, [{
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var offset = this._viewportProps.offset;
      return this._getUpdatedState({
        startPanPosition: pos,
        startPanOffset: offset
      });
    }
    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos;
      var _this$_interactiveSta = this._interactiveState,
          startPanPosition = _this$_interactiveSta.startPanPosition,
          startPanOffset = _this$_interactiveSta.startPanOffset;
      var delta = new Vector2(pos).subtract(startPanPosition);
      return this._getUpdatedState({
        offset: new Vector2(startPanOffset).subtract(delta)
      });
    }
    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedState({
        startPanPosition: null,
        startPanOffset: null
      });
    }
    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: "rotateStart",
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;
      return this;
    }
    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: "rotate",
    value: function rotate(_ref5) {
      var deltaScaleX = _ref5.deltaScaleX,
          deltaScaleY = _ref5.deltaScaleY;
      return this;
    }
    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this;
    } // Calculates new zoom

  }, {
    key: "_calculateNewZoom",
    value: function _calculateNewZoom(_ref6) {
      var scale = _ref6.scale,
          startZoom = _ref6.startZoom;
      var _this$_viewportProps = this._viewportProps,
          maxZoom = _this$_viewportProps.maxZoom,
          minZoom = _this$_viewportProps.minZoom;
      var zoom = startZoom + Math.log2(scale);
      return clamp(zoom, minZoom, maxZoom);
    }
    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: "zoomStart",
    value: function zoomStart(_ref7) {
      var pos = _ref7.pos;
      return this._getUpdatedState({
        startZoomPosition: pos,
        startZoom: this._viewportProps.zoom
      });
    }
    /**
     * Zoom
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     * @param {[number, number]} pos - current mouse cursor screen position
     */

  }, {
    key: "zoom",
    value: function zoom(_ref8) {
      var pos = _ref8.pos,
          startPos = _ref8.startPos,
          scale = _ref8.scale;
      var _this$_viewportProps2 = this._viewportProps,
          zoom = _this$_viewportProps2.zoom,
          width = _this$_viewportProps2.width,
          height = _this$_viewportProps2.height,
          offset = _this$_viewportProps2.offset;
      var _this$_interactiveSta2 = this._interactiveState,
          startZoom = _this$_interactiveSta2.startZoom,
          startZoomPosition = _this$_interactiveSta2.startZoomPosition;

      if (!Number.isFinite(startZoom)) {
        // We have two modes of zoom:
        // scroll zoom that are discrete events (transform from the current zoom level),
        // and pinch zoom that are continuous events (transform from the zoom level when
        // pinch started).
        // If startZoom state is defined, then use the startZoom state;
        // otherwise assume discrete zooming
        startZoom = zoom;
        startZoomPosition = startPos || pos;
      }

      var newZoom = this._calculateNewZoom({
        scale: scale,
        startZoom: startZoom
      });

      var startScale = zoom2Scale(startZoom);
      var newScale = zoom2Scale(newZoom);
      var centerX = width / 2 - offset[0];
      var centerY = height / 2 - offset[1];
      var dX = (startZoomPosition[0] - centerX) * (newScale / startScale - 1);
      var dY = (startZoomPosition[1] - centerY) * (newScale / startScale - 1);
      return this._getUpdatedState({
        zoom: newZoom,
        offset: [offset[0] + dX, offset[1] + dY]
      });
    }
    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null,
        startZoom: null
      });
    }
  }, {
    key: "_zoomFromCenter",
    value: function _zoomFromCenter(scale) {
      var _this$_viewportProps3 = this._viewportProps,
          width = _this$_viewportProps3.width,
          height = _this$_viewportProps3.height,
          offset = _this$_viewportProps3.offset;
      return this.zoom({
        pos: [width / 2 - offset[0], height / 2 - offset[1]],
        scale: scale
      });
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this._zoomFromCenter(2);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this._zoomFromCenter(0.5);
    }
  }, {
    key: "moveLeft",
    value: function moveLeft() {
      var offset = this._viewportProps.offset;
      var delta = [MOVEMENT_SPEED, 0];
      return this._getUpdatedState({
        offset: new Vector2(offset).add(delta)
      });
    }
  }, {
    key: "moveRight",
    value: function moveRight() {
      var offset = this._viewportProps.offset;
      var delta = [-MOVEMENT_SPEED, 0];
      return this._getUpdatedState({
        offset: new Vector2(offset).add(delta)
      });
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      var offset = this._viewportProps.offset;
      var delta = [0, MOVEMENT_SPEED];
      return this._getUpdatedState({
        offset: new Vector2(offset).add(delta)
      });
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      var offset = this._viewportProps.offset;
      var delta = [0, -MOVEMENT_SPEED];
      return this._getUpdatedState({
        offset: new Vector2(offset).add(delta)
      });
    }
    /* Private methods */

  }, {
    key: "_getUpdatedState",
    value: function _getUpdatedState(newProps) {
      // Update _viewportProps
      return new OrthographicState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }
  }]);

  return OrthographicState;
}(ViewState);

var OrthographicController =
/*#__PURE__*/
function (_Controller) {
  _inherits(OrthographicController, _Controller);

  function OrthographicController(props) {
    var _this2;

    _classCallCheck(this, OrthographicController);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(OrthographicController).call(this, OrthographicState, props));
    _this2.invertPan = true;
    return _this2;
  }

  _createClass(OrthographicController, [{
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      return this._onPanRotateMap(event);
    }
  }]);

  return OrthographicController;
}(Controller);

export { OrthographicController as default };
//# sourceMappingURL=orthographic-controller.js.map
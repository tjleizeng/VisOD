{"version":3,"sources":["../../../../../src/experimental/utils/gpu-grid-aggregation/grid-aggregation-utils.js"],"names":["assert","Matrix4","fp64","fp64Utils","COORDINATE_SYSTEM","AGGREGATION_OPERATION","fp64LowPart","R_EARTH","pointToDensityGridData","data","getPosition","cellSizeMeters","gpuGridAggregator","gpuAggregation","aggregationFlags","getWeight","d","coordinateSystem","LNGLAT","viewport","boundingBox","gridData","dataChanged","cellSizeChanged","viewportChanged","parseGridData","cellSize","worldOrigin","IDENTITY","LNGLAT_DEPRECATED","gridOffset","getGridOffset","xOffset","yOffset","width","height","opts","getGPUAggregationParams","aggregatedData","run","positions","positions64xyLow","weights","gridTransformMatrix","useGPU","changeFlags","countsBuffer","weight1","aggregationBuffer","maxCountBuffer","maxBuffer","countsData","aggregationData","maxCountData","maxData","gridSize","gridOrigin","weightValues","yMin","Infinity","yMax","xMin","xMax","y","x","p","length","position","push","weight","Array","isArray","Number","isFinite","size","operation","SUM","needMax","values","latMin","latMax","centerLat","calculateGridLatLonOffset","latitude","calculateLatOffset","calculateLonOffset","dy","Math","PI","lat","dx","cos","alignToCell","inValue","sign","value","abs","floor","originX","originY","translate","ceil"],"mappings":"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","sourcesContent":["import assert from '../../../utils/assert';\nimport {Matrix4} from 'math.gl';\nimport {fp64 as fp64Utils} from 'luma.gl';\nimport {COORDINATE_SYSTEM} from '../../../lib/constants';\nimport {AGGREGATION_OPERATION} from './gpu-grid-aggregator-constants';\nconst {fp64LowPart} = fp64Utils;\n\nconst R_EARTH = 6378000;\n\n// Takes data and aggregation params and returns aggregated data.\nexport function pointToDensityGridData({\n  data,\n  getPosition,\n  cellSizeMeters,\n  gpuGridAggregator,\n  gpuAggregation,\n  aggregationFlags,\n  getWeight = d => [1.0, 0, 0],\n  fp64 = false,\n  coordinateSystem = COORDINATE_SYSTEM.LNGLAT,\n  viewport = null,\n  boundingBox = null\n}) {\n  let gridData = {};\n  assert(\n    aggregationFlags.dataChanged ||\n      aggregationFlags.cellSizeChanged ||\n      aggregationFlags.viewportChanged\n  );\n  if (aggregationFlags.dataChanged) {\n    gridData = parseGridData(data, getPosition, getWeight);\n    boundingBox = gridData.boundingBox;\n  }\n  let cellSize = [cellSizeMeters, cellSizeMeters];\n  let worldOrigin = [0, 0];\n  assert(\n    coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.IDENTITY\n  );\n  assert(boundingBox);\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n    case COORDINATE_SYSTEM.LNGLAT_DEPRECATED:\n      const gridOffset = getGridOffset(boundingBox, cellSizeMeters);\n      cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n      worldOrigin = [-180, -90]; // Origin used to define grid cell boundaries\n      break;\n    case COORDINATE_SYSTEM.IDENTITY:\n      const {width, height} = viewport;\n      worldOrigin = [-width / 2, -height / 2]; // Origin used to define grid cell boundaries\n      break;\n    default:\n      // Currently other coodinate systems not supported/verified.\n      assert(false);\n  }\n\n  const opts = getGPUAggregationParams({boundingBox, cellSize, worldOrigin});\n\n  const aggregatedData = gpuGridAggregator.run({\n    positions: gridData.positions,\n    positions64xyLow: gridData.positions64xyLow,\n    weights: gridData.weights,\n    cellSize,\n    width: opts.width,\n    height: opts.height,\n    gridTransformMatrix: opts.gridTransformMatrix,\n    useGPU: gpuAggregation,\n    changeFlags: aggregationFlags,\n    fp64\n  });\n\n  return {\n    countsBuffer: aggregatedData.weight1.aggregationBuffer,\n    maxCountBuffer: aggregatedData.weight1.maxBuffer,\n    countsData: aggregatedData.weight1.aggregationData,\n    maxCountData: aggregatedData.weight1.maxData,\n    gridSize: opts.gridSize,\n    gridOrigin: opts.gridOrigin,\n    cellSize,\n    boundingBox\n  };\n}\n\n// Parse input data to build positions, wights and bounding box.\n/* eslint-disable max-statements */\nfunction parseGridData(data, getPosition, getWeight = null) {\n  assert(data && getPosition);\n  const positions = [];\n  const positions64xyLow = [];\n  const weightValues = [];\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n  for (let p = 0; p < data.length; p++) {\n    const position = getPosition(data[p]);\n    x = position[0];\n    y = position[1];\n    positions.push(x, y);\n    positions64xyLow.push(fp64LowPart(x), fp64LowPart(y));\n\n    let weight = getWeight ? getWeight(data[p]) : [1.0, 0, 0];\n    // Aggregator expects each weight is an array of size 3\n    if (!Array.isArray(weight)) {\n      // backward compitability\n      weight = [weight, 0, 0];\n    }\n    assert(weight.length === 3);\n    weightValues.push(...weight);\n\n    if (Number.isFinite(y) && Number.isFinite(x)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n  const weights = {\n    weight1: {\n      size: 1,\n      operation: AGGREGATION_OPERATION.SUM,\n      needMax: true,\n      values: weightValues\n    }\n  };\n  const boundingBox = {xMin, xMax, yMin, yMax};\n  return {\n    positions,\n    positions64xyLow,\n    weights,\n    boundingBox\n  };\n}\n/* eslint-enable max-statements */\n\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} gridData - contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @returns {yOffset, xOffset} - cellSize size lng/lat (degree) space.\n */\n\nfunction getGridOffset(boundingBox, cellSize) {\n  const {yMin, yMax} = boundingBox;\n  const latMin = yMin;\n  const latMax = yMax;\n  const centerLat = (latMin + latMax) / 2;\n\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = calculateLatOffset(cellSize);\n  const xOffset = calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n\n// Aligns `inValue` to given `cellSize`\nexport function alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n\n  value = Math.floor(value / cellSize) * cellSize;\n\n  return value * sign;\n}\n\n// Calculate grid parameters\nfunction getGPUAggregationParams({boundingBox, cellSize, worldOrigin}) {\n  const {yMin, yMax, xMin, xMax} = boundingBox;\n\n  // NOTE: this alignment will match grid cell boundaries with existing CPU implementation\n  // this gurantees identical aggregation results when switching between CPU and GPU aggregation.\n  // Also gurantees same cell boundaries, when overlapping between two different layers (like ScreenGrid and Contour)\n  // We first move worldOrigin to [0, 0], align the lower bounding box , then move worldOrigin to its original value.\n  const originX = alignToCell(xMin - worldOrigin[0], cellSize[0]) + worldOrigin[0];\n  const originY = alignToCell(yMin - worldOrigin[1], cellSize[1]) + worldOrigin[1];\n\n  // Setup transformation matrix so that every point is in +ve range\n  const gridTransformMatrix = new Matrix4().translate([-1 * originX, -1 * originY, 0]);\n\n  // const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n  const gridOrigin = [originX, originY];\n  const width = xMax - xMin + cellSize[0];\n  const height = yMax - yMin + cellSize[1];\n\n  const gridSize = [Math.ceil(width / cellSize[0]), Math.ceil(height / cellSize[1])];\n\n  return {\n    gridOrigin,\n    gridSize,\n    width,\n    height,\n    gridTransformMatrix\n  };\n}\n"],"file":"grid-aggregation-utils.js"}
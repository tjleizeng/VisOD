import Controller from './controller';
import ViewState from './view-state';
import { Vector2, clamp } from 'math.gl';
const MOVEMENT_SPEED = 10; // per keyboard click

const DEFAULT_STATE = {
  zoom: 0,
  offset: [0, 0],
  minZoom: -10,
  maxZoom: 10
};

const zoom2Scale = zoom => Math.pow(2, zoom);

class OrthographicState extends ViewState {
  constructor(_ref) {
    let width = _ref.width,
        height = _ref.height,
        _ref$offset = _ref.offset,
        offset = _ref$offset === void 0 ? DEFAULT_STATE.offset : _ref$offset,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === void 0 ? DEFAULT_STATE.zoom : _ref$zoom,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === void 0 ? DEFAULT_STATE.minZoom : _ref$minZoom,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === void 0 ? DEFAULT_STATE.maxZoom : _ref$maxZoom,
        startPanPosition = _ref.startPanPosition,
        startPanOffset = _ref.startPanOffset,
        startZoomPosition = _ref.startZoomPosition,
        startZoom = _ref.startZoom;
    super({
      width,
      height,
      offset,
      zoom,
      minZoom,
      maxZoom
    });
    this._interactiveState = {
      startPanPosition,
      startPanOffset,
      startZoomPosition,
      startZoom
    };
  }
  /* Public API */


  getInteractiveState() {
    return this._interactiveState;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */


  panStart(_ref2) {
    let pos = _ref2.pos;
    const offset = this._viewportProps.offset;
    return this._getUpdatedState({
      startPanPosition: pos,
      startPanOffset: offset
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */


  pan(_ref3) {
    let pos = _ref3.pos;
    const _this$_interactiveSta = this._interactiveState,
          startPanPosition = _this$_interactiveSta.startPanPosition,
          startPanOffset = _this$_interactiveSta.startPanOffset;
    const delta = new Vector2(pos).subtract(startPanPosition);
    return this._getUpdatedState({
      offset: new Vector2(startPanOffset).subtract(delta)
    });
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */


  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null,
      startPanOffset: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */


  rotateStart(_ref4) {
    let pos = _ref4.pos;
    return this;
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */


  rotate(_ref5) {
    let deltaScaleX = _ref5.deltaScaleX,
        deltaScaleY = _ref5.deltaScaleY;
    return this;
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */


  rotateEnd() {
    return this;
  } // Calculates new zoom


  _calculateNewZoom(_ref6) {
    let scale = _ref6.scale,
        startZoom = _ref6.startZoom;
    const _this$_viewportProps = this._viewportProps,
          maxZoom = _this$_viewportProps.maxZoom,
          minZoom = _this$_viewportProps.minZoom;
    const zoom = startZoom + Math.log2(scale);
    return clamp(zoom, minZoom, maxZoom);
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */


  zoomStart(_ref7) {
    let pos = _ref7.pos;
    return this._getUpdatedState({
      startZoomPosition: pos,
      startZoom: this._viewportProps.zoom
    });
  }
  /**
   * Zoom
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   * @param {[number, number]} pos - current mouse cursor screen position
   */


  zoom(_ref8) {
    let pos = _ref8.pos,
        startPos = _ref8.startPos,
        scale = _ref8.scale;
    const _this$_viewportProps2 = this._viewportProps,
          zoom = _this$_viewportProps2.zoom,
          width = _this$_viewportProps2.width,
          height = _this$_viewportProps2.height,
          offset = _this$_viewportProps2.offset;
    let _this$_interactiveSta2 = this._interactiveState,
        startZoom = _this$_interactiveSta2.startZoom,
        startZoomPosition = _this$_interactiveSta2.startZoomPosition;

    if (!Number.isFinite(startZoom)) {
      // We have two modes of zoom:
      // scroll zoom that are discrete events (transform from the current zoom level),
      // and pinch zoom that are continuous events (transform from the zoom level when
      // pinch started).
      // If startZoom state is defined, then use the startZoom state;
      // otherwise assume discrete zooming
      startZoom = zoom;
      startZoomPosition = startPos || pos;
    }

    const newZoom = this._calculateNewZoom({
      scale,
      startZoom
    });

    const startScale = zoom2Scale(startZoom);
    const newScale = zoom2Scale(newZoom);
    const centerX = width / 2 - offset[0];
    const centerY = height / 2 - offset[1];
    const dX = (startZoomPosition[0] - centerX) * (newScale / startScale - 1);
    const dY = (startZoomPosition[1] - centerY) * (newScale / startScale - 1);
    return this._getUpdatedState({
      zoom: newZoom,
      offset: [offset[0] + dX, offset[1] + dY]
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */


  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }

  _zoomFromCenter(scale) {
    const _this$_viewportProps3 = this._viewportProps,
          width = _this$_viewportProps3.width,
          height = _this$_viewportProps3.height,
          offset = _this$_viewportProps3.offset;
    return this.zoom({
      pos: [width / 2 - offset[0], height / 2 - offset[1]],
      scale
    });
  }

  zoomIn() {
    return this._zoomFromCenter(2);
  }

  zoomOut() {
    return this._zoomFromCenter(0.5);
  }

  moveLeft() {
    const offset = this._viewportProps.offset;
    const delta = [MOVEMENT_SPEED, 0];
    return this._getUpdatedState({
      offset: new Vector2(offset).add(delta)
    });
  }

  moveRight() {
    const offset = this._viewportProps.offset;
    const delta = [-MOVEMENT_SPEED, 0];
    return this._getUpdatedState({
      offset: new Vector2(offset).add(delta)
    });
  }

  moveUp() {
    const offset = this._viewportProps.offset;
    const delta = [0, MOVEMENT_SPEED];
    return this._getUpdatedState({
      offset: new Vector2(offset).add(delta)
    });
  }

  moveDown() {
    const offset = this._viewportProps.offset;
    const delta = [0, -MOVEMENT_SPEED];
    return this._getUpdatedState({
      offset: new Vector2(offset).add(delta)
    });
  }
  /* Private methods */


  _getUpdatedState(newProps) {
    // Update _viewportProps
    return new OrthographicState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
  }

}

export default class OrthographicController extends Controller {
  constructor(props) {
    super(OrthographicState, props);
    this.invertPan = true;
  }

  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }

    return this._onPanRotateMap(event);
  }

}
//# sourceMappingURL=orthographic-controller.js.map
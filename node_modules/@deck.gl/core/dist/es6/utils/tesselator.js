// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { fillArray } from './flatten';

class TypedArrayManager {
  constructor() {
    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$overAlloc = _ref.overAlloc,
        overAlloc = _ref$overAlloc === void 0 ? 1 : _ref$overAlloc;

    this.overAlloc = overAlloc;
  }

  allocate(typedArray, count, _ref2) {
    let size = _ref2.size,
        type = _ref2.type,
        _ref2$copy = _ref2.copy,
        copy = _ref2$copy === void 0 ? false : _ref2$copy;
    const newSize = count * size;

    if (typedArray && newSize <= typedArray.length) {
      return typedArray;
    } // Allocate at least one element to ensure a valid buffer


    const allocSize = Math.max(Math.ceil(newSize * this.overAlloc), 1);

    const newArray = this._allocate(type, allocSize);

    if (typedArray && copy) {
      newArray.set(typedArray);
    }

    this._release(typedArray);

    return newArray;
  }

  _allocate() {
    let Type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Float32Array;
    let size = arguments.length > 1 ? arguments[1] : undefined;

    if (Type === Uint16Array && size > 65535) {
      throw new Error('Vertex count exceeds browser index limit');
    } // TODO - check if available in pool


    return new Type(size);
  }

  _release(typedArray) {// TODO - add to pool
    // logFunctions.onUpdate({
    //   level: LOG_DETAIL_PRIORITY,
    //   message: `${attributeName} allocated ${allocCount}`,
    //   id: this.id
    // });
  }

}

export default class Tesselator {
  constructor() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const _opts$attributes = opts.attributes,
          attributes = _opts$attributes === void 0 ? {} : _opts$attributes;
    this.typedArrayManager = new TypedArrayManager();
    this.indexLayout = null;
    this.bufferLayout = null;
    this.vertexCount = 0;
    this.instanceCount = 0;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.updateGeometry(opts);
    Object.seal(this);
  }
  /* Public methods */


  updateGeometry(_ref3) {
    let data = _ref3.data,
        getGeometry = _ref3.getGeometry,
        positionFormat = _ref3.positionFormat,
        fp64 = _ref3.fp64;
    this.data = data;
    this.getGeometry = getGeometry;
    this.fp64 = fp64;
    this.positionSize = positionFormat === 'XY' ? 2 : 3;

    this._rebuildGeometry();
  }

  updatePartialGeometry(_ref4) {
    let start = _ref4.start,
        count = _ref4.count,
        objects = _ref4.objects;
  } // TODO

  /* Subclass interface */
  // Update the positions of a single geometry


  updateGeometryAttributes(geometry, startIndex, size) {
    throw new Error('Not implemented');
  } // Returns the number of vertices in a geometry


  getGeometrySize(geometry) {
    throw new Error('Not implemented');
  }
  /* Private utility methods */

  /**
   * Visit all objects
   * `data` is expected to be an iterable consistent with the base Layer expectation
   */


  _forEachGeometry(visitor) {
    const data = this.data,
          getGeometry = this.getGeometry;
    let dataIndex = 0;

    for (const object of data) {
      const geometry = getGeometry(object);
      visitor(geometry, dataIndex++);
    }
  }

  _updateAttribute(_ref5) {
    let target = _ref5.target,
        size = _ref5.size,
        getValue = _ref5.getValue;
    const data = this.data,
          bufferLayout = this.bufferLayout;
    let i = 0;
    let dataIndex = 0;

    for (const object of data) {
      const value = getValue(object, dataIndex);
      const numVertices = bufferLayout[dataIndex++];
      fillArray({
        target,
        source: value,
        start: i,
        count: numVertices
      });
      i += numVertices * size;
    }

    return target;
  }

  _rebuildGeometry() {
    if (!this.data || !this.getGeometry) {
      return;
    } // count instances


    const indexLayout = [];
    const bufferLayout = [];
    let instanceCount = 0;

    this._forEachGeometry((geometry, dataIndex) => {
      const count = this.getGeometrySize(geometry);
      instanceCount += count;
      bufferLayout[dataIndex] = count;
    }); // allocate attributes


    const attributes = this.attributes,
          _attributeDefs = this._attributeDefs,
          typedArrayManager = this.typedArrayManager,
          fp64 = this.fp64;

    for (const name in _attributeDefs) {
      const def = _attributeDefs[name]; // do not create fp64-only attributes unless in fp64 mode

      if (!def.fp64Only || fp64) {
        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
      }
    }

    this.indexLayout = indexLayout;
    this.bufferLayout = bufferLayout;
    this.instanceCount = instanceCount;
    const context = {
      vertexStart: 0,
      indexStart: 0
    };

    this._forEachGeometry((geometry, dataIndex) => {
      const geometrySize = bufferLayout[dataIndex];
      context.geometryIndex = dataIndex;
      context.geometrySize = geometrySize;
      this.updateGeometryAttributes(geometry, context);
      context.vertexStart += geometrySize;
      context.indexStart += indexLayout[dataIndex] || 0;
    });

    this.vertexCount = context.indexStart;
  }

}
//# sourceMappingURL=tesselator.js.map
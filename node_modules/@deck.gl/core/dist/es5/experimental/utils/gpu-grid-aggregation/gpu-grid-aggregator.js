"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _core = require("@deck.gl/core");

var _assert = _interopRequireDefault(require("../../../utils/assert"));

var _viewportMercatorProject = require("viewport-mercator-project");

var _gpuGridAggregatorConstants = require("./gpu-grid-aggregator-constants");

var _aggregateToGridVs = _interopRequireDefault(require("./aggregate-to-grid-vs.glsl"));

var _aggregateToGridVs2 = _interopRequireDefault(require("./aggregate-to-grid-vs-64.glsl"));

var _aggregateToGridFs = _interopRequireDefault(require("./aggregate-to-grid-fs.glsl"));

var _aggregateAllVs = _interopRequireDefault(require("./aggregate-all-vs-64.glsl"));

var _aggregateAllFs = _interopRequireDefault(require("./aggregate-all-fs.glsl"));

var _transformMeanVs = _interopRequireDefault(require("./transform-mean-vs.glsl"));

var _gpuGridAggregatorUtils = require("./gpu-grid-aggregator-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fp64ifyMatrix4 = _luma.fp64.fp64ifyMatrix4;

var GPUGridAggregator =
/*#__PURE__*/
function () {
  _createClass(GPUGridAggregator, null, [{
    key: "getAggregationData",
    // Decode and return aggregation data of given pixel.
    value: function getAggregationData(_ref) {
      var aggregationData = _ref.aggregationData,
          maxData = _ref.maxData,
          pixelIndex = _ref.pixelIndex;
      (0, _assert.default)(aggregationData.length >= (pixelIndex + 1) * _gpuGridAggregatorConstants.PIXEL_SIZE);
      (0, _assert.default)(maxData.length === _gpuGridAggregatorConstants.PIXEL_SIZE);
      var index = pixelIndex * _gpuGridAggregatorConstants.PIXEL_SIZE;
      var cellCount = aggregationData[index + 3];
      var cellWeight = aggregationData[index];
      var totalCount = maxData[3];
      var maxCellWieght = maxData[0];
      return {
        cellCount: cellCount,
        cellWeight: cellWeight,
        totalCount: totalCount,
        maxCellWieght: maxCellWieght
      };
    } // Decodes and retuns counts and weights of all cells

  }, {
    key: "getCellData",
    value: function getCellData(_ref2) {
      var countsData = _ref2.countsData,
          _ref2$size = _ref2.size,
          size = _ref2$size === void 0 ? 1 : _ref2$size;
      var cellWeights = [];
      var cellCounts = [];

      for (var index = 0; index < countsData.length; index += 4) {
        // weights in RGB channels
        for (var sizeIndex = 0; sizeIndex < size; sizeIndex++) {
          cellWeights.push(countsData[index + sizeIndex]);
        } // count in Alpha channel


        cellCounts.push(countsData[index + 3]);
      }

      return {
        cellCounts: cellCounts,
        cellWeights: cellWeights
      };
    } // DEBUG ONLY
    // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer}) {
    //   const agrData = aggregationBuffer.getData();
    //   for (let index = 0; index < agrData.length; index += 4) {
    //     if (agrData[index + 3] > 0) {
    //       console.log(
    //         `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${
    //           agrData[index + 2]
    //         } count: ${agrData[index + 3]}`
    //       );
    //     }
    //   }
    // }

  }]);

  function GPUGridAggregator(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, GPUGridAggregator);

    this.id = opts.id || 'gpu-grid-aggregator';
    this.shaderCache = opts.shaderCache || null;
    this.gl = gl;
    this.state = {
      // cache weights and position data to process when data is not changed
      weights: null,
      gridPositions: null,
      positionsBuffer: null,
      positions64xyLowBuffer: null,
      vertexCount: 0,
      // flags/variables that affect the aggregation
      fp64: null,
      useGPU: null,
      numCol: 0,
      numRow: 0,
      windowSize: null,
      cellSize: null,
      // per weight GPU resources
      weightAttributes: {},
      textures: {},
      meanTextures: {},
      buffers: {},
      framebuffers: {},
      maxMinFramebuffers: {},
      minFramebuffers: {},
      maxFramebuffers: {},
      equations: {}
    };
    this._hasGPUSupport = (0, _luma.isWebGL2)(gl) && // gl_InstanceID usage in min/max calculation shaders
    (0, _luma.hasFeatures)(this.gl, _luma.FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes
    _luma.FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture
    _luma.FEATURES.TEXTURE_FLOAT // sample from a float texture
    );
  } // Delete owned resources.

  /* eslint no-unused-expressions: ["error", { "allowShortCircuit": true }] */


  _createClass(GPUGridAggregator, [{
    key: "delete",
    value: function _delete() {
      var gridAggregationModel = this.gridAggregationModel,
          allAggregationModel = this.allAggregationModel,
          meanTransform = this.meanTransform;
      var _this$state = this.state,
          positionsBuffer = _this$state.positionsBuffer,
          position64Buffer = _this$state.position64Buffer,
          framebuffers = _this$state.framebuffers,
          maxMinFramebuffers = _this$state.maxMinFramebuffers,
          minFramebuffers = _this$state.minFramebuffers,
          maxFramebuffers = _this$state.maxFramebuffers,
          meanTextures = _this$state.meanTextures;
      gridAggregationModel && gridAggregationModel.delete();
      allAggregationModel && allAggregationModel.delete();
      meanTransform && meanTransform.delete();
      positionsBuffer && positionsBuffer.delete();
      position64Buffer && position64Buffer.delete();
      this.deleteResources(framebuffers);
      this.deleteResources(maxMinFramebuffers);
      this.deleteResources(minFramebuffers);
      this.deleteResources(maxFramebuffers);
      this.deleteResources(meanTextures);
    } // Perform aggregation and retun the results

  }, {
    key: "run",
    value: function run() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var aggregationParams = this.getAggregationParams(opts);
      (0, _assert.default)(aggregationParams);
      this.updateGridSize(aggregationParams);
      var useGPU = aggregationParams.useGPU;

      if (this._hasGPUSupport && useGPU) {
        return this.runAggregationOnGPU(aggregationParams);
      }

      if (useGPU) {
        _core.log.warn('ScreenGridAggregator: GPU Aggregation not supported, falling back to CPU')();
      }

      return this.runAggregationOnCPU(aggregationParams);
    } // PRIVATE
    // Common methods

  }, {
    key: "deleteResources",
    value: function deleteResources(obj) {
      for (var name in obj) {
        obj[name].delete();
      }
    }
  }, {
    key: "getAggregationParams",
    value: function getAggregationParams(opts) {
      var aggregationParams = Object.assign({}, _gpuGridAggregatorConstants.DEFAULT_RUN_PARAMS, opts);
      var useGPU = aggregationParams.useGPU,
          gridTransformMatrix = aggregationParams.gridTransformMatrix,
          viewport = aggregationParams.viewport,
          weights = aggregationParams.weights,
          projectPoints = aggregationParams.projectPoints,
          cellSize = aggregationParams.cellSize;

      if (this.state.useGPU !== useGPU) {
        // CPU/GPU resources need to reinitialized, force set the change flags.
        aggregationParams.changeFlags = Object.assign({}, aggregationParams.changeFlags, _gpuGridAggregatorConstants.DEFAULT_CHANGE_FLAGS);
      }

      if (cellSize && (!this.state.cellSize || this.state.cellSize[0] !== cellSize[0] || this.state.cellSize[1] !== cellSize[1])) {
        aggregationParams.changeFlags.cellSizeChanged = true; // For GridLayer aggregation, cellSize is calculated by parsing all input data as it depends
        // on bounding box, cache cellSize

        this.setState({
          cellSize: cellSize
        });
      }

      this.validateProps(aggregationParams, opts);
      this.setState({
        useGPU: useGPU
      });
      aggregationParams.gridTransformMatrix = (projectPoints ? viewport.viewportMatrix : gridTransformMatrix) || _gpuGridAggregatorConstants.IDENTITY_MATRIX;

      if (weights) {
        aggregationParams.weights = this.normalizeWeightParams(weights); // cache weights to process when only cellSize or viewport is changed.
        // position data is cached in Buffers for GPU case and in 'gridPositions' for CPU case.

        this.setState({
          weights: aggregationParams.weights
        });
      }

      return aggregationParams;
    }
  }, {
    key: "normalizeWeightParams",
    value: function normalizeWeightParams(weights) {
      var result = {};

      for (var id in weights) {
        result[id] = Object.assign({}, _gpuGridAggregatorConstants.DEFAULT_WEIGHT_PARAMS, weights[id]);
      }

      return result;
    } // Update priveate state

  }, {
    key: "setState",
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
    }
  }, {
    key: "shouldTransformToGrid",
    value: function shouldTransformToGrid(opts) {
      var projectPoints = opts.projectPoints,
          changeFlags = opts.changeFlags;

      if (!this.state.gridPositions || changeFlags.dataChanged || projectPoints && changeFlags.viewportChanged // world space aggregation (GridLayer) doesn't change when viewport is changed.
      ) {
          return true;
        }

      return false;
    }
  }, {
    key: "updateGridSize",
    value: function updateGridSize(opts) {
      var viewport = opts.viewport,
          cellSize = opts.cellSize;
      var width = opts.width || viewport.width;
      var height = opts.height || viewport.height;
      var numCol = Math.ceil(width / cellSize[0]);
      var numRow = Math.ceil(height / cellSize[1]);
      this.setState({
        numCol: numCol,
        numRow: numRow,
        windowSize: [width, height]
      });
    } // validate and assert

  }, {
    key: "validateProps",
    value: function validateProps(aggregationParams, opts) {
      var changeFlags = aggregationParams.changeFlags,
          projectPoints = aggregationParams.projectPoints,
          gridTransformMatrix = aggregationParams.gridTransformMatrix;
      (0, _assert.default)(changeFlags.dataChanged || changeFlags.viewportChanged || changeFlags.cellSizeChanged); // assert for required options

      (0, _assert.default)(!changeFlags.dataChanged || opts.positions && opts.weights && (!opts.projectPositions || opts.viewport) && opts.cellSize);
      (0, _assert.default)(!changeFlags.cellSizeChanged || opts.cellSize); // viewport need only when performing screen space aggregation (projectPoints is true)

      (0, _assert.default)(!(changeFlags.viewportChanged && projectPoints) || opts.viewport);

      if (projectPoints && gridTransformMatrix) {
        _core.log.warn('projectPoints is true, gridTransformMatrix is ignored')();
      }
    } // CPU Aggregation methods
    // aggregated weight value to a cell

    /* eslint-disable max-depth */

  }, {
    key: "calculateAggregationData",
    value: function calculateAggregationData(opts) {
      var weights = opts.weights,
          results = opts.results,
          cellIndex = opts.cellIndex,
          posIndex = opts.posIndex;

      for (var id in weights) {
        var _weights$id = weights[id],
            values = _weights$id.values,
            size = _weights$id.size,
            operation = _weights$id.operation;
        var aggregationData = results[id].aggregationData;
        (0, _assert.default)(size >= 1 && size <= 3); // Fill RGB with weights

        for (var sizeIndex = 0; sizeIndex < size; sizeIndex++) {
          var cellElementIndex = cellIndex + sizeIndex;
          var weightComponent = values[posIndex * _gpuGridAggregatorConstants.WEIGHT_SIZE + sizeIndex];
          (0, _assert.default)(Number.isFinite(weightComponent));

          if (aggregationData[cellIndex + 3] === 0) {
            // if the cell is getting update the first time, set the value directly.
            aggregationData[cellElementIndex] = weightComponent;
          } else {
            switch (operation) {
              case _gpuGridAggregatorConstants.AGGREGATION_OPERATION.SUM:
              case _gpuGridAggregatorConstants.AGGREGATION_OPERATION.MEAN:
                aggregationData[cellElementIndex] += weightComponent; // MEAN value is calculated during 'calculateMeanMaxMinData'

                break;

              case _gpuGridAggregatorConstants.AGGREGATION_OPERATION.MIN:
                aggregationData[cellElementIndex] = Math.min(aggregationData[cellElementIndex], weightComponent);
                break;

              case _gpuGridAggregatorConstants.AGGREGATION_OPERATION.MAX:
                aggregationData[cellElementIndex] = Math.max(aggregationData[cellElementIndex], weightComponent);
                break;

              default:
                // Not a valid operation enum.
                (0, _assert.default)(false);
                break;
            }
          }
        } // Track the count per grid-cell


        aggregationData[cellIndex + 3]++;
      }
    }
    /* eslint-disable max-depth, complexity */

  }, {
    key: "calculateMeanMaxMinData",
    value: function calculateMeanMaxMinData(opts) {
      var validCellIndices = opts.validCellIndices,
          results = opts.results,
          weights = opts.weights; // collect max/min values

      validCellIndices.forEach(function (cellIndex) {
        for (var id in results) {
          var _weights$id2 = weights[id],
              size = _weights$id2.size,
              needMin = _weights$id2.needMin,
              needMax = _weights$id2.needMax,
              operation = _weights$id2.operation;
          var _results$id = results[id],
              aggregationData = _results$id.aggregationData,
              minData = _results$id.minData,
              maxData = _results$id.maxData,
              maxMinData = _results$id.maxMinData;
          var calculateMinMax = needMin || needMax;
          var calculateMean = operation === _gpuGridAggregatorConstants.AGGREGATION_OPERATION.MEAN;
          var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
          var count = aggregationData[cellIndex + _gpuGridAggregatorConstants.ELEMENTCOUNT - 1];

          for (var sizeIndex = 0; sizeIndex < size && (calculateMinMax || calculateMean); sizeIndex++) {
            var cellElementIndex = cellIndex + sizeIndex;
            var weight = aggregationData[cellElementIndex];

            if (calculateMean) {
              aggregationData[cellElementIndex] /= count;
              weight = aggregationData[cellElementIndex];
            }

            if (combineMaxMin) {
              // use RGB for max values for 3 weights.
              maxMinData[sizeIndex] = Math.max(maxMinData[sizeIndex], weight);
            } else {
              if (needMin) {
                minData[sizeIndex] = Math.min(minData[sizeIndex], weight);
              }

              if (needMax) {
                maxData[sizeIndex] = Math.max(maxData[sizeIndex], weight);
              }
            }
          } // update total aggregation values.


          if (combineMaxMin) {
            // Use Alpha channel to store total min value for weight#0
            maxMinData[_gpuGridAggregatorConstants.ELEMENTCOUNT - 1] = Math.min(maxMinData[_gpuGridAggregatorConstants.ELEMENTCOUNT - 1], aggregationData[cellIndex + 0]);
          } else {
            // Use Alpha channel to store total counts.
            if (needMin) {
              minData[_gpuGridAggregatorConstants.ELEMENTCOUNT - 1] += count;
            }

            if (needMax) {
              maxData[_gpuGridAggregatorConstants.ELEMENTCOUNT - 1] += count;
            }
          }
        }
      });
    }
    /* eslint-enable max-depth */

  }, {
    key: "initCPUResults",
    value: function initCPUResults(opts) {
      var weights = opts.weights || this.state.weights;
      var _this$state2 = this.state,
          numCol = _this$state2.numCol,
          numRow = _this$state2.numRow;
      var results = {}; // setup results object

      for (var id in weights) {
        var _weights$id3 = weights[id],
            aggregationData = _weights$id3.aggregationData,
            minData = _weights$id3.minData,
            maxData = _weights$id3.maxData,
            maxMinData = _weights$id3.maxMinData;
        var _weights$id4 = weights[id],
            needMin = _weights$id4.needMin,
            needMax = _weights$id4.needMax;
        var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
        var aggregationSize = numCol * numRow * _gpuGridAggregatorConstants.ELEMENTCOUNT;
        aggregationData = (0, _gpuGridAggregatorUtils.getFloatArray)(aggregationData, aggregationSize);

        if (combineMaxMin) {
          maxMinData = (0, _gpuGridAggregatorUtils.getFloatArray)(maxMinData, _gpuGridAggregatorConstants.ELEMENTCOUNT); // RGB for max value

          maxMinData.fill(-Infinity, 0, _gpuGridAggregatorConstants.ELEMENTCOUNT - 1); // Alpha for min value

          maxMinData[_gpuGridAggregatorConstants.ELEMENTCOUNT - 1] = Infinity;
        } else {
          // RGB for min/max values
          // Alpha for total count
          if (needMin) {
            minData = (0, _gpuGridAggregatorUtils.getFloatArray)(minData, _gpuGridAggregatorConstants.ELEMENTCOUNT, Infinity);
            minData[_gpuGridAggregatorConstants.ELEMENTCOUNT - 1] = 0;
          }

          if (needMax) {
            maxData = (0, _gpuGridAggregatorUtils.getFloatArray)(maxData, _gpuGridAggregatorConstants.ELEMENTCOUNT, -Infinity);
            maxData[_gpuGridAggregatorConstants.ELEMENTCOUNT - 1] = 0;
          }
        }

        results[id] = Object.assign({}, weights[id], {
          aggregationData: aggregationData,
          minData: minData,
          maxData: maxData,
          maxMinData: maxMinData
        });
      }

      return results;
    }
    /* eslint-disable max-statements */

  }, {
    key: "runAggregationOnCPU",
    value: function runAggregationOnCPU(opts) {
      var positions = opts.positions,
          cellSize = opts.cellSize,
          gridTransformMatrix = opts.gridTransformMatrix,
          viewport = opts.viewport,
          projectPoints = opts.projectPoints;
      var weights = opts.weights;
      var _this$state3 = this.state,
          numCol = _this$state3.numCol,
          numRow = _this$state3.numRow;
      var results = this.initCPUResults(opts); // screen space or world space projection required

      var gridTransformRequired = this.shouldTransformToGrid(opts);
      var gridPositions = [];
      (0, _assert.default)(gridTransformRequired || opts.changeFlags.cellSizeChanged);
      var posCount;

      if (gridTransformRequired) {
        this.setState({
          gridPositions: gridPositions
        });
        posCount = positions.length / 2;
      } else {
        gridPositions = this.state.gridPositions;
        weights = this.state.weights;
        posCount = gridPositions.length / 2;
      }

      var validCellIndices = new Set();

      for (var posIndex = 0; posIndex < posCount; posIndex++) {
        var gridPos = void 0;

        if (gridTransformRequired) {
          var _gridPositions;

          var pos = [positions[posIndex * 2], positions[posIndex * 2 + 1]];

          if (projectPoints) {
            gridPos = viewport.project([pos[0], pos[1]]);
          } else {
            gridPos = (0, _viewportMercatorProject.worldToPixels)([pos[0], pos[1], 0], gridTransformMatrix).slice(0, 2);
          }

          (_gridPositions = gridPositions).push.apply(_gridPositions, _toConsumableArray(gridPos));
        } else {
          gridPos = [gridPositions[posIndex * 2], gridPositions[posIndex * 2 + 1]];
        }

        var x = gridPos[0];
        var y = gridPos[1];
        var colId = Math.floor(x / cellSize[0]);
        var rowId = Math.floor(y / cellSize[1]);

        if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {
          var cellIndex = (colId + rowId * numCol) * _gpuGridAggregatorConstants.ELEMENTCOUNT;
          validCellIndices.add(cellIndex);
          this.calculateAggregationData({
            weights: weights,
            results: results,
            cellIndex: cellIndex,
            posIndex: posIndex
          });
        }
      }

      this.calculateMeanMaxMinData({
        validCellIndices: validCellIndices,
        results: results,
        weights: weights
      }); // Update buffer objects.

      this.updateAggregationBuffers(opts, results);
      return results;
    }
    /* eslint-disable max-statements */

  }, {
    key: "updateAggregationBuffers",
    value: function updateAggregationBuffers(opts, results) {
      if (!opts.createBufferObjects) {
        return;
      }

      var weights = opts.weights || this.state.weights;

      for (var id in results) {
        var _results$id2 = results[id],
            aggregationData = _results$id2.aggregationData,
            minData = _results$id2.minData,
            maxData = _results$id2.maxData,
            maxMinData = _results$id2.maxMinData;
        var _weights$id5 = weights[id],
            needMin = _weights$id5.needMin,
            needMax = _weights$id5.needMax;
        var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
        (0, _gpuGridAggregatorUtils.updateBuffer)({
          gl: this.gl,
          bufferName: 'aggregationBuffer',
          data: aggregationData,
          result: results[id]
        });

        if (combineMaxMin) {
          (0, _gpuGridAggregatorUtils.updateBuffer)({
            gl: this.gl,
            bufferName: 'maxMinBuffer',
            data: maxMinData,
            result: results[id]
          });
        } else {
          if (needMin) {
            (0, _gpuGridAggregatorUtils.updateBuffer)({
              gl: this.gl,
              bufferName: 'minBuffer',
              data: minData,
              result: results[id]
            });
          }

          if (needMax) {
            (0, _gpuGridAggregatorUtils.updateBuffer)({
              gl: this.gl,
              bufferName: 'maxBuffer',
              data: maxData,
              result: results[id]
            });
          }
        }
      }
    } // GPU Aggregation methods

  }, {
    key: "getAggregateData",
    value: function getAggregateData(opts) {
      var results = {};
      var _this$state4 = this.state,
          textures = _this$state4.textures,
          framebuffers = _this$state4.framebuffers,
          maxMinFramebuffers = _this$state4.maxMinFramebuffers,
          minFramebuffers = _this$state4.minFramebuffers,
          maxFramebuffers = _this$state4.maxFramebuffers,
          weights = _this$state4.weights;

      for (var id in weights) {
        results[id] = {};
        var _weights$id6 = weights[id],
            needMin = _weights$id6.needMin,
            needMax = _weights$id6.needMax,
            combineMaxMin = _weights$id6.combineMaxMin;
        results[id].aggregationTexture = textures[id];
        results[id].aggregationBuffer = framebuffers[id].readPixelsToBuffer({
          buffer: weights[id].aggregationBuffer,
          // update if a buffer is provided
          type: _constants.default.FLOAT
        });

        if (needMin && needMax && combineMaxMin) {
          results[id].maxMinBuffer = maxMinFramebuffers[id].readPixelsToBuffer({
            buffer: weights[id].maxMinBuffer,
            // update if a buffer is provided
            type: _constants.default.FLOAT
          });
        } else {
          if (needMin) {
            results[id].minBuffer = minFramebuffers[id].readPixelsToBuffer({
              buffer: weights[id].minBuffer,
              // update if a buffer is provided
              type: _constants.default.FLOAT
            });
          }

          if (needMax) {
            results[id].maxBuffer = maxFramebuffers[id].readPixelsToBuffer({
              buffer: weights[id].maxBuffer,
              // update if a buffer is provided
              type: _constants.default.FLOAT
            });
          }
        }
      }

      return results;
    }
  }, {
    key: "getAggregationModel",
    value: function getAggregationModel() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var gl = this.gl,
          shaderCache = this.shaderCache;
      return new _luma.Model(gl, {
        id: 'Gird-Aggregation-Model',
        vs: fp64 ? _aggregateToGridVs2.default : _aggregateToGridVs.default,
        fs: _aggregateToGridFs.default,
        modules: fp64 ? ['fp64', 'project64'] : ['project32'],
        shaderCache: shaderCache,
        vertexCount: 0,
        drawMode: _constants.default.POINTS
      });
    }
  }, {
    key: "getAllAggregationModel",
    value: function getAllAggregationModel() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var gl = this.gl,
          shaderCache = this.shaderCache;
      return new _luma.Model(gl, {
        id: 'All-Aggregation-Model',
        vs: _aggregateAllVs.default,
        fs: _aggregateAllFs.default,
        modules: ['fp64'],
        shaderCache: shaderCache,
        vertexCount: 1,
        drawMode: _constants.default.POINTS,
        isInstanced: true,
        instanceCount: 0,
        attributes: {
          position: new _luma.Buffer(gl, {
            size: 2,
            data: new Float32Array([0, 0])
          })
        }
      });
    }
  }, {
    key: "getMeanTransform",
    value: function getMeanTransform(opts) {
      if (this.meanTransform) {
        this.meanTransform.update(opts);
      } else {
        this.meanTransform = new _luma.Transform(this.gl, Object.assign({}, {
          vs: _transformMeanVs.default,
          _targetTextureVarying: 'meanValues'
        }, opts));
      }

      return this.meanTransform;
    }
  }, {
    key: "renderAggregateData",
    value: function renderAggregateData(opts) {
      var cellSize = opts.cellSize,
          viewport = opts.viewport,
          gridTransformMatrix = opts.gridTransformMatrix,
          projectPoints = opts.projectPoints;
      var _this$state5 = this.state,
          numCol = _this$state5.numCol,
          numRow = _this$state5.numRow,
          windowSize = _this$state5.windowSize,
          maxMinFramebuffers = _this$state5.maxMinFramebuffers,
          minFramebuffers = _this$state5.minFramebuffers,
          maxFramebuffers = _this$state5.maxFramebuffers,
          weights = _this$state5.weights;
      var uProjectionMatrixFP64 = fp64ifyMatrix4(gridTransformMatrix);
      var gridSize = [numCol, numRow];
      var parameters = {
        blend: true,
        depthTest: false,
        blendFunc: [_constants.default.ONE, _constants.default.ONE]
      };
      var moduleSettings = {
        viewport: viewport
      };
      var uniforms = {
        windowSize: windowSize,
        cellSize: cellSize,
        gridSize: gridSize,
        uProjectionMatrix: gridTransformMatrix,
        uProjectionMatrixFP64: uProjectionMatrixFP64,
        projectPoints: projectPoints
      };

      for (var id in weights) {
        var _weights$id7 = weights[id],
            needMin = _weights$id7.needMin,
            needMax = _weights$id7.needMax;
        var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
        this.renderToWeightsTexture({
          id: id,
          parameters: parameters,
          moduleSettings: moduleSettings,
          uniforms: uniforms,
          gridSize: gridSize
        });

        if (combineMaxMin) {
          this.renderToMaxMinTexture({
            id: id,
            parameters: Object.assign({}, parameters, {
              blendEquation: _gpuGridAggregatorConstants.MAX_MIN_BLEND_EQUATION
            }),
            gridSize: gridSize,
            minOrMaxFb: maxMinFramebuffers[id],
            clearParams: {
              clearColor: [0, 0, 0, _gpuGridAggregatorConstants.MAX_32_BIT_FLOAT]
            },
            combineMaxMin: combineMaxMin
          });
        } else {
          if (needMin) {
            this.renderToMaxMinTexture({
              id: id,
              parameters: Object.assign({}, parameters, {
                blendEquation: _gpuGridAggregatorConstants.MIN_BLEND_EQUATION
              }),
              gridSize: gridSize,
              minOrMaxFb: minFramebuffers[id],
              clearParams: {
                clearColor: [_gpuGridAggregatorConstants.MAX_32_BIT_FLOAT, _gpuGridAggregatorConstants.MAX_32_BIT_FLOAT, _gpuGridAggregatorConstants.MAX_32_BIT_FLOAT, 0]
              },
              combineMaxMin: combineMaxMin
            });
          }

          if (needMax) {
            this.renderToMaxMinTexture({
              id: id,
              parameters: Object.assign({}, parameters, {
                blendEquation: _gpuGridAggregatorConstants.MAX_BLEND_EQUATION
              }),
              gridSize: gridSize,
              minOrMaxFb: maxFramebuffers[id],
              combineMaxMin: combineMaxMin
            });
          }
        }
      }
    } // render all aggregated grid-cells to generate Min, Max or MaxMin data texture

  }, {
    key: "renderToMaxMinTexture",
    value: function renderToMaxMinTexture(opts) {
      var id = opts.id,
          parameters = opts.parameters,
          gridSize = opts.gridSize,
          minOrMaxFb = opts.minOrMaxFb,
          combineMaxMin = opts.combineMaxMin,
          _opts$clearParams = opts.clearParams,
          clearParams = _opts$clearParams === void 0 ? {} : _opts$clearParams;
      var framebuffers = this.state.framebuffers;
      var gl = this.gl,
          allAggregationModel = this.allAggregationModel;
      minOrMaxFb.bind();
      gl.viewport(0, 0, gridSize[0], gridSize[1]);
      (0, _luma.withParameters)(gl, clearParams, function () {
        gl.clear(gl.COLOR_BUFFER_BIT);
      });
      allAggregationModel.draw({
        parameters: parameters,
        uniforms: {
          uSampler: framebuffers[id].texture,
          gridSize: gridSize,
          combineMaxMin: combineMaxMin
        }
      });
      minOrMaxFb.unbind();
    } // render all data points to aggregate weights

  }, {
    key: "renderToWeightsTexture",
    value: function renderToWeightsTexture(opts) {
      var id = opts.id,
          parameters = opts.parameters,
          moduleSettings = opts.moduleSettings,
          uniforms = opts.uniforms,
          gridSize = opts.gridSize;
      var _this$state6 = this.state,
          framebuffers = _this$state6.framebuffers,
          equations = _this$state6.equations,
          weightAttributes = _this$state6.weightAttributes,
          weights = _this$state6.weights;
      var gl = this.gl,
          gridAggregationModel = this.gridAggregationModel;
      var operation = weights[id].operation;
      framebuffers[id].bind();
      gl.viewport(0, 0, gridSize[0], gridSize[1]);
      var clearColor = operation === _gpuGridAggregatorConstants.AGGREGATION_OPERATION.MIN ? [_gpuGridAggregatorConstants.MAX_32_BIT_FLOAT, _gpuGridAggregatorConstants.MAX_32_BIT_FLOAT, _gpuGridAggregatorConstants.MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];
      (0, _luma.withParameters)(gl, {
        clearColor: clearColor
      }, function () {
        gl.clear(gl.COLOR_BUFFER_BIT);
      });
      var attributes = {
        weights: weightAttributes[id]
      };
      gridAggregationModel.draw({
        parameters: Object.assign({}, parameters, {
          blendEquation: equations[id]
        }),
        moduleSettings: moduleSettings,
        uniforms: uniforms,
        attributes: attributes
      });
      framebuffers[id].unbind();

      if (operation === _gpuGridAggregatorConstants.AGGREGATION_OPERATION.MEAN) {
        var _this$state7 = this.state,
            meanTextures = _this$state7.meanTextures,
            textures = _this$state7.textures;
        var transformOptions = {
          _sourceTextures: {
            aggregationValues: meanTextures[id]
          },
          // contains aggregated data
          _targetTexture: textures[id],
          // store mean values,
          elementCount: textures[id].width * textures[id].height
        };
        var meanTransform = this.getMeanTransform(transformOptions);
        meanTransform.run({
          parameters: {
            blend: false,
            depthTest: false
          }
        }); // update framebuffer with mean results so readPixelsToBuffer returns mean values

        framebuffers[id].attach(_defineProperty({}, _constants.default.COLOR_ATTACHMENT0, textures[id]));
      }
    }
  }, {
    key: "runAggregationOnGPU",
    value: function runAggregationOnGPU(opts) {
      this.updateModels(opts);
      this.setupFramebuffers(opts);
      this.renderAggregateData(opts);
      return this.getAggregateData(opts);
    } // set up framebuffer for each weight

    /* eslint-disable complexity, max-depth */

  }, {
    key: "setupFramebuffers",
    value: function setupFramebuffers(opts) {
      var _this$state8 = this.state,
          numCol = _this$state8.numCol,
          numRow = _this$state8.numRow,
          textures = _this$state8.textures,
          framebuffers = _this$state8.framebuffers,
          maxMinFramebuffers = _this$state8.maxMinFramebuffers,
          minFramebuffers = _this$state8.minFramebuffers,
          maxFramebuffers = _this$state8.maxFramebuffers,
          meanTextures = _this$state8.meanTextures,
          equations = _this$state8.equations,
          weights = _this$state8.weights;
      var framebufferSize = {
        width: numCol,
        height: numRow
      };

      for (var id in weights) {
        var _weights$id8 = weights[id],
            needMin = _weights$id8.needMin,
            needMax = _weights$id8.needMax,
            combineMaxMin = _weights$id8.combineMaxMin,
            operation = _weights$id8.operation;
        textures[id] = weights[id].aggregationTexture || textures[id] || (0, _gpuGridAggregatorUtils.getFloatTexture)(this.gl, {
          id: "".concat(id, "-texture"),
          width: numCol,
          height: numRow
        });
        textures[id].resize(framebufferSize);
        var texture = textures[id];

        if (operation === _gpuGridAggregatorConstants.AGGREGATION_OPERATION.MEAN) {
          // For MEAN, we first aggregatet into a temp texture
          meanTextures[id] = meanTextures[id] || (0, _gpuGridAggregatorUtils.getFloatTexture)(this.gl, {
            id: "".concat(id, "-mean-texture"),
            width: numCol,
            height: numRow
          });
          meanTextures[id].resize(framebufferSize);
          texture = meanTextures[id];
        }

        if (framebuffers[id]) {
          framebuffers[id].attach(_defineProperty({}, _constants.default.COLOR_ATTACHMENT0, texture));
        } else {
          framebuffers[id] = (0, _gpuGridAggregatorUtils.getFramebuffer)(this.gl, {
            id: "".concat(id, "-fb"),
            width: numCol,
            height: numRow,
            texture: texture
          });
        }

        framebuffers[id].resize(framebufferSize);
        equations[id] = _gpuGridAggregatorConstants.EQUATION_MAP[operation]; // For min/max framebuffers will use default size 1X1

        if (needMin || needMax) {
          if (needMin && needMax && combineMaxMin) {
            maxMinFramebuffers[id] = maxMinFramebuffers[id] || (0, _gpuGridAggregatorUtils.getFramebuffer)(this.gl, {
              id: "".concat(id, "-maxMinFb")
            });
          } else {
            if (needMin) {
              minFramebuffers[id] = minFramebuffers[id] || (0, _gpuGridAggregatorUtils.getFramebuffer)(this.gl, {
                id: "".concat(id, "-minFb")
              });
            }

            if (needMax) {
              maxFramebuffers[id] = maxFramebuffers[id] || (0, _gpuGridAggregatorUtils.getFramebuffer)(this.gl, {
                id: "".concat(id, "-maxFb")
              });
            }
          }
        }
      }
    }
    /* eslint-enable complexity, max-depth */

  }, {
    key: "setupModels",
    value: function setupModels() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.gridAggregationModel) {
        this.gridAggregationModel.delete();
      }

      this.gridAggregationModel = this.getAggregationModel(fp64);

      if (this.allAggregationModel) {
        this.allAggregationModel.delete();
      }

      this.allAggregationModel = this.getAllAggregationModel(fp64);
    } // set up buffers for all weights

  }, {
    key: "setupWeightAttributes",
    value: function setupWeightAttributes(opts) {
      var _this$state9 = this.state,
          weightAttributes = _this$state9.weightAttributes,
          vertexCount = _this$state9.vertexCount,
          weights = _this$state9.weights;

      for (var id in weights) {
        var values = weights[id].values; // values can be Array, Float32Array or Buffer

        if (Array.isArray(values) || values.constructor === Float32Array) {
          (0, _assert.default)(values.length / 3 === vertexCount);
          var typedArray = Array.isArray(values) ? new Float32Array(values) : values;

          if (weightAttributes[id] instanceof _luma.Buffer) {
            weightAttributes[id].setData(typedArray);
          } else {
            weightAttributes[id] = new _luma.Buffer(this.gl, typedArray);
          }
        } else {
          // assert((values instanceof Attribute) || (values instanceof Buffer));
          (0, _assert.default)(values instanceof _luma.Buffer);
          weightAttributes[id] = values;
        }
      }
    }
    /* eslint-disable max-statements */

  }, {
    key: "updateModels",
    value: function updateModels(opts) {
      var gl = this.gl;
      var positions = opts.positions,
          positions64xyLow = opts.positions64xyLow,
          changeFlags = opts.changeFlags;
      var _this$state10 = this.state,
          numCol = _this$state10.numCol,
          numRow = _this$state10.numRow;
      var _this$state11 = this.state,
          positionsBuffer = _this$state11.positionsBuffer,
          positions64xyLowBuffer = _this$state11.positions64xyLowBuffer;
      var aggregationModelAttributes = {};
      var createPos64xyLow = false;

      if (opts.fp64 !== this.state.fp64) {
        this.setupModels(opts.fp64);
        this.setState({
          fp64: opts.fp64
        });

        if (opts.fp64) {
          createPos64xyLow = true;
        }
      }

      if (changeFlags.dataChanged || !positionsBuffer) {
        if (positionsBuffer) {
          positionsBuffer.delete();
        }

        var vertexCount = positions.length / 2; // positionsBuffer = new Buffer(gl, {size: 2, data: new Float32Array(positions)});

        positionsBuffer = new _luma.Buffer(gl, new Float32Array(positions));
        createPos64xyLow = opts.fp64;
        Object.assign(aggregationModelAttributes, {
          positions: positionsBuffer
        });
        this.setState({
          positionsBuffer: positionsBuffer,
          vertexCount: vertexCount
        });
        this.setupWeightAttributes(opts);
        this.gridAggregationModel.setVertexCount(vertexCount);
      }

      if (createPos64xyLow) {
        (0, _assert.default)(positions64xyLow);

        if (positions64xyLowBuffer) {
          positions64xyLowBuffer.delete();
        }

        positions64xyLowBuffer = new _luma.Buffer(gl, {
          size: 2,
          data: new Float32Array(positions64xyLow)
        });
        Object.assign(aggregationModelAttributes, {
          positions64xyLow: positions64xyLowBuffer
        });
        this.setState({
          positions64xyLowBuffer: positions64xyLowBuffer
        });
      }

      this.gridAggregationModel.setAttributes(aggregationModelAttributes);

      if (changeFlags.cellSizeChanged || changeFlags.viewportChanged) {
        this.allAggregationModel.setInstanceCount(numCol * numRow);
      }
    }
    /* eslint-enable max-statements */

  }]);

  return GPUGridAggregator;
}();

exports.default = GPUGridAggregator;
//# sourceMappingURL=gpu-grid-aggregator.js.map
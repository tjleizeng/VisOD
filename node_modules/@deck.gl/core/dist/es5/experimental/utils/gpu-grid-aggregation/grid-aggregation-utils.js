"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointToDensityGridData = pointToDensityGridData;
exports.alignToCell = alignToCell;

var _assert = _interopRequireDefault(require("../../../utils/assert"));

var _math = require("math.gl");

var _luma = require("luma.gl");

var _constants = require("../../../lib/constants");

var _gpuGridAggregatorConstants = require("./gpu-grid-aggregator-constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var fp64LowPart = _luma.fp64.fp64LowPart;
var R_EARTH = 6378000; // Takes data and aggregation params and returns aggregated data.

function pointToDensityGridData(_ref) {
  var data = _ref.data,
      getPosition = _ref.getPosition,
      cellSizeMeters = _ref.cellSizeMeters,
      gpuGridAggregator = _ref.gpuGridAggregator,
      gpuAggregation = _ref.gpuAggregation,
      aggregationFlags = _ref.aggregationFlags,
      _ref$getWeight = _ref.getWeight,
      getWeight = _ref$getWeight === void 0 ? function (d) {
    return [1.0, 0, 0];
  } : _ref$getWeight,
      _ref$fp = _ref.fp64,
      fp64 = _ref$fp === void 0 ? false : _ref$fp,
      _ref$coordinateSystem = _ref.coordinateSystem,
      coordinateSystem = _ref$coordinateSystem === void 0 ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref$coordinateSystem,
      _ref$viewport = _ref.viewport,
      viewport = _ref$viewport === void 0 ? null : _ref$viewport,
      _ref$boundingBox = _ref.boundingBox,
      boundingBox = _ref$boundingBox === void 0 ? null : _ref$boundingBox;
  var gridData = {};
  (0, _assert.default)(aggregationFlags.dataChanged || aggregationFlags.cellSizeChanged || aggregationFlags.viewportChanged);

  if (aggregationFlags.dataChanged) {
    gridData = parseGridData(data, getPosition, getWeight);
    boundingBox = gridData.boundingBox;
  }

  var cellSize = [cellSizeMeters, cellSizeMeters];
  var worldOrigin = [0, 0];
  (0, _assert.default)(coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants.COORDINATE_SYSTEM.IDENTITY);
  (0, _assert.default)(boundingBox);

  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
      var gridOffset = getGridOffset(boundingBox, cellSizeMeters);
      cellSize = [gridOffset.xOffset, gridOffset.yOffset];
      worldOrigin = [-180, -90]; // Origin used to define grid cell boundaries

      break;

    case _constants.COORDINATE_SYSTEM.IDENTITY:
      var width = viewport.width,
          height = viewport.height;
      worldOrigin = [-width / 2, -height / 2]; // Origin used to define grid cell boundaries

      break;

    default:
      // Currently other coodinate systems not supported/verified.
      (0, _assert.default)(false);
  }

  var opts = getGPUAggregationParams({
    boundingBox: boundingBox,
    cellSize: cellSize,
    worldOrigin: worldOrigin
  });
  var aggregatedData = gpuGridAggregator.run({
    positions: gridData.positions,
    positions64xyLow: gridData.positions64xyLow,
    weights: gridData.weights,
    cellSize: cellSize,
    width: opts.width,
    height: opts.height,
    gridTransformMatrix: opts.gridTransformMatrix,
    useGPU: gpuAggregation,
    changeFlags: aggregationFlags,
    fp64: fp64
  });
  return {
    countsBuffer: aggregatedData.weight1.aggregationBuffer,
    maxCountBuffer: aggregatedData.weight1.maxBuffer,
    countsData: aggregatedData.weight1.aggregationData,
    maxCountData: aggregatedData.weight1.maxData,
    gridSize: opts.gridSize,
    gridOrigin: opts.gridOrigin,
    cellSize: cellSize,
    boundingBox: boundingBox
  };
} // Parse input data to build positions, wights and bounding box.

/* eslint-disable max-statements */


function parseGridData(data, getPosition) {
  var getWeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  (0, _assert.default)(data && getPosition);
  var positions = [];
  var positions64xyLow = [];
  var weightValues = [];
  var yMin = Infinity;
  var yMax = -Infinity;
  var xMin = Infinity;
  var xMax = -Infinity;
  var y;
  var x;

  for (var p = 0; p < data.length; p++) {
    var position = getPosition(data[p]);
    x = position[0];
    y = position[1];
    positions.push(x, y);
    positions64xyLow.push(fp64LowPart(x), fp64LowPart(y));
    var weight = getWeight ? getWeight(data[p]) : [1.0, 0, 0]; // Aggregator expects each weight is an array of size 3

    if (!Array.isArray(weight)) {
      // backward compitability
      weight = [weight, 0, 0];
    }

    (0, _assert.default)(weight.length === 3);
    weightValues.push.apply(weightValues, _toConsumableArray(weight));

    if (Number.isFinite(y) && Number.isFinite(x)) {
      yMin = y < yMin ? y : yMin;
      yMax = y > yMax ? y : yMax;
      xMin = x < xMin ? x : xMin;
      xMax = x > xMax ? x : xMax;
    }
  }

  var weights = {
    weight1: {
      size: 1,
      operation: _gpuGridAggregatorConstants.AGGREGATION_OPERATION.SUM,
      needMax: true,
      values: weightValues
    }
  };
  var boundingBox = {
    xMin: xMin,
    xMax: xMax,
    yMin: yMin,
    yMax: yMax
  };
  return {
    positions: positions,
    positions64xyLow: positions64xyLow,
    weights: weights,
    boundingBox: boundingBox
  };
}
/* eslint-enable max-statements */

/**
 * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space
 * @param {object} gridData - contains bounding box of data
 * @param {number} cellSize - grid cell size in meters
 * @returns {yOffset, xOffset} - cellSize size lng/lat (degree) space.
 */


function getGridOffset(boundingBox, cellSize) {
  var yMin = boundingBox.yMin,
      yMax = boundingBox.yMax;
  var latMin = yMin;
  var latMax = yMax;
  var centerLat = (latMin + latMax) / 2;
  return calculateGridLatLonOffset(cellSize, centerLat);
}
/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} cellSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */


function calculateGridLatLonOffset(cellSize, latitude) {
  var yOffset = calculateLatOffset(cellSize);
  var xOffset = calculateLonOffset(latitude, cellSize);
  return {
    yOffset: yOffset,
    xOffset: xOffset
  };
}
/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */


function calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}
/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */


function calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
} // Aligns `inValue` to given `cellSize`


function alignToCell(inValue, cellSize) {
  var sign = inValue < 0 ? -1 : 1;
  var value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);
  value = Math.floor(value / cellSize) * cellSize;
  return value * sign;
} // Calculate grid parameters


function getGPUAggregationParams(_ref2) {
  var boundingBox = _ref2.boundingBox,
      cellSize = _ref2.cellSize,
      worldOrigin = _ref2.worldOrigin;
  var yMin = boundingBox.yMin,
      yMax = boundingBox.yMax,
      xMin = boundingBox.xMin,
      xMax = boundingBox.xMax; // NOTE: this alignment will match grid cell boundaries with existing CPU implementation
  // this gurantees identical aggregation results when switching between CPU and GPU aggregation.
  // Also gurantees same cell boundaries, when overlapping between two different layers (like ScreenGrid and Contour)
  // We first move worldOrigin to [0, 0], align the lower bounding box , then move worldOrigin to its original value.

  var originX = alignToCell(xMin - worldOrigin[0], cellSize[0]) + worldOrigin[0];
  var originY = alignToCell(yMin - worldOrigin[1], cellSize[1]) + worldOrigin[1]; // Setup transformation matrix so that every point is in +ve range

  var gridTransformMatrix = new _math.Matrix4().translate([-1 * originX, -1 * originY, 0]); // const cellSize = [gridOffset.xOffset, gridOffset.yOffset];

  var gridOrigin = [originX, originY];
  var width = xMax - xMin + cellSize[0];
  var height = yMax - yMin + cellSize[1];
  var gridSize = [Math.ceil(width / cellSize[0]), Math.ceil(height / cellSize[1])];
  return {
    gridOrigin: gridOrigin,
    gridSize: gridSize,
    width: width,
    height: height,
    gridTransformMatrix: gridTransformMatrix
  };
}
//# sourceMappingURL=grid-aggregation-utils.js.map
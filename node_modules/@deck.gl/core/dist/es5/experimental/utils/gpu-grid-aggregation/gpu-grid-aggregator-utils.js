"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFloatTexture = getFloatTexture;
exports.getFramebuffer = getFramebuffer;
exports.getFloatArray = getFloatArray;
exports.updateBuffer = updateBuffer;

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getFloatTexture(gl, opts) {
  var _parameters;

  var _opts$width = opts.width,
      width = _opts$width === void 0 ? 1 : _opts$width,
      _opts$height = opts.height,
      height = _opts$height === void 0 ? 1 : _opts$height;
  var texture = new _luma.Texture2D(gl, {
    data: null,
    format: _constants.default.RGBA32F,
    type: _constants.default.FLOAT,
    border: 0,
    mipmaps: false,
    parameters: (_parameters = {}, _defineProperty(_parameters, _constants.default.TEXTURE_MAG_FILTER, _constants.default.NEAREST), _defineProperty(_parameters, _constants.default.TEXTURE_MIN_FILTER, _constants.default.NEAREST), _parameters),
    dataFormat: _constants.default.RGBA,
    width: width,
    height: height
  });
  return texture;
}

function getFramebuffer(gl, opts) {
  var id = opts.id,
      _opts$width2 = opts.width,
      width = _opts$width2 === void 0 ? 1 : _opts$width2,
      _opts$height2 = opts.height,
      height = _opts$height2 === void 0 ? 1 : _opts$height2;
  var texture = opts.texture || getFloatTexture(gl, opts);
  var fb = new _luma.Framebuffer(gl, {
    id: id,
    width: width,
    height: height,
    attachments: _defineProperty({}, _constants.default.COLOR_ATTACHMENT0, texture)
  });
  return fb;
}

function getFloatArray(array, size) {
  var fillValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (!array || array.length < size) {
    return new Float32Array(size).fill(fillValue);
  }

  return array;
}

function updateBuffer(_ref) {
  var gl = _ref.gl,
      bufferName = _ref.bufferName,
      data = _ref.data,
      result = _ref.result;

  if (result[bufferName]) {
    result[bufferName].subData({
      data: data
    });
  } else {
    result[bufferName] = new _luma.Buffer(gl, data);
  }
}
//# sourceMappingURL=gpu-grid-aggregator-utils.js.map
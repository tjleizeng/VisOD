function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* global document */
import GL from 'luma.gl/constants';
import { Texture2D, loadImages, loadTextures } from 'luma.gl';
var MAX_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;
var DEFAULT_TEXTURE_MIN_FILTER = GL.LINEAR_MIPMAP_LINEAR; // GL.LINEAR is the default value but explicitly set it here

var DEFAULT_TEXTURE_MAG_FILTER = GL.LINEAR;

var noop = function noop() {};

function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
} // resize image to given width and height


function resizeImage(ctx, imageData, width, height) {
  var naturalWidth = imageData.naturalWidth,
      naturalHeight = imageData.naturalHeight;

  if (width === naturalWidth && height === naturalHeight) {
    return imageData;
  }

  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight

  ctx.drawImage(imageData, 0, 0, naturalWidth, naturalHeight, 0, 0, width, height);
  return ctx.canvas;
} // traverse icons in a row of icon atlas
// extend each icon with left-top coordinates


function buildRowMapping(mapping, columns, yOffset) {
  for (var i = 0; i < columns.length; i++) {
    var _columns$i = columns[i],
        icon = _columns$i.icon,
        xOffset = _columns$i.xOffset;
    mapping[icon.url] = Object.assign({}, icon, {
      x: xOffset,
      y: yOffset
    });
  }
}
/**
 * Generate coordinate mapping to retrieve icon left-top position from an icon atlas
 * @param icons {Array<Object>} list of icons, each icon requires url, width, height
 * @param buffer {Number} add buffer to the right and bottom side of the image
 * @param maxCanvasHeight {Number}
 * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}
 */


export function buildMapping(_ref) {
  var icons = _ref.icons,
      buffer = _ref.buffer,
      maxCanvasWidth = _ref.maxCanvasWidth;
  // x position till current column
  var xOffset = 0; // y position till current row

  var yOffset = 0; // height of current row

  var rowHeight = 0;
  var columns = [];
  var mapping = {}; // Strategy to layout all the icons into a texture:
  // traverse the icons sequentially, layout the icons from left to right, top to bottom
  // when the sum of the icons width is equal or larger than maxCanvasWidth,
  // move to next row starting from total height so far plus max height of the icons in previous row
  // row width is equal to maxCanvasWidth
  // row height is decided by the max height of the icons in that row
  // mapping coordinates of each icon is its left-top position in the texture

  for (var i = 0; i < icons.length; i++) {
    var icon = icons[i];

    if (!mapping[icon.url]) {
      var height = icon.height,
          width = icon.width; // fill one row

      if (xOffset + width + buffer > maxCanvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }

      columns.push({
        icon: icon,
        xOffset: xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }

  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }

  var canvasHeight = nextPowOfTwo(rowHeight + yOffset + buffer);
  return {
    mapping: mapping,
    canvasHeight: canvasHeight
  };
} // extract unique icons from data

function getIcons(data, getIcon) {
  if (!data || !getIcon) {
    return null;
  }

  var icons = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var point = _step.value;
      var icon = getIcon(point);

      if (!icon) {
        throw new Error('Icon is missing.');
      }

      if (!icon.url) {
        throw new Error('Icon url is missing.');
      }

      if (!icons[icon.url]) {
        icons[icon.url] = icon;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return icons;
}

var IconManager =
/*#__PURE__*/
function () {
  function IconManager(gl, _ref2) {
    var _ref2$onUpdate = _ref2.onUpdate,
        onUpdate = _ref2$onUpdate === void 0 ? noop : _ref2$onUpdate;

    _classCallCheck(this, IconManager);

    this.gl = gl;
    this.onUpdate = onUpdate;
    this._getIcon = null;
    this._mapping = {};
    this._texture = null;
    this._autoPacking = false;
    this._canvas = null;
  }

  _createClass(IconManager, [{
    key: "getTexture",
    value: function getTexture() {
      return this._texture;
    }
  }, {
    key: "getIconMapping",
    value: function getIconMapping(dataPoint) {
      var icon = this._getIcon(dataPoint);

      var name = this._autoPacking ? icon.url : icon;
      return this._mapping[name] || {};
    }
  }, {
    key: "setProps",
    value: function setProps(_ref3) {
      var autoPacking = _ref3.autoPacking,
          iconAtlas = _ref3.iconAtlas,
          iconMapping = _ref3.iconMapping,
          data = _ref3.data,
          getIcon = _ref3.getIcon;

      if (autoPacking !== undefined) {
        this._autoPacking = autoPacking;
      }

      if (getIcon) {
        this._getIcon = getIcon;
      }

      if (iconMapping) {
        this._mapping = iconMapping;
      }

      if (iconAtlas) {
        this._updateIconAtlas(iconAtlas);
      }

      if (this._autoPacking && (data || getIcon)) {
        this._canvas = this._canvas || document.createElement('canvas');

        this._updateAutoPacking({
          data: data,
          buffer: DEFAULT_BUFFER,
          maxCanvasWidth: MAX_CANVAS_WIDTH
        });
      }
    }
  }, {
    key: "_updateIconAtlas",
    value: function _updateIconAtlas(iconAtlas) {
      var _this = this;

      if (iconAtlas instanceof Texture2D) {
        var _iconAtlas$setParamet;

        iconAtlas.setParameters((_iconAtlas$setParamet = {}, _defineProperty(_iconAtlas$setParamet, GL.TEXTURE_MIN_FILTER, DEFAULT_TEXTURE_MIN_FILTER), _defineProperty(_iconAtlas$setParamet, GL.TEXTURE_MAG_FILTER, DEFAULT_TEXTURE_MAG_FILTER), _iconAtlas$setParamet));
        this._texture = iconAtlas;
        this.onUpdate();
      } else if (typeof iconAtlas === 'string') {
        var _parameters;

        loadTextures(this.gl, {
          urls: [iconAtlas],
          parameters: (_parameters = {}, _defineProperty(_parameters, GL.TEXTURE_MIN_FILTER, DEFAULT_TEXTURE_MIN_FILTER), _defineProperty(_parameters, GL.TEXTURE_MAG_FILTER, DEFAULT_TEXTURE_MAG_FILTER), _parameters)
        }).then(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 1),
              texture = _ref5[0];

          _this._texture = texture;

          _this.onUpdate();
        });
      }
    }
  }, {
    key: "_updateAutoPacking",
    value: function _updateAutoPacking(_ref6) {
      var data = _ref6.data,
          buffer = _ref6.buffer,
          maxCanvasWidth = _ref6.maxCanvasWidth;
      var icons = Object.values(getIcons(data, this._getIcon) || {});

      if (icons.length > 0) {
        // generate icon mapping
        var _buildMapping = buildMapping({
          icons: icons,
          buffer: buffer,
          maxCanvasWidth: maxCanvasWidth
        }),
            mapping = _buildMapping.mapping,
            canvasHeight = _buildMapping.canvasHeight;

        this._mapping = mapping; // create new texture

        this._texture = new Texture2D(this.gl, {
          width: maxCanvasWidth,
          height: canvasHeight
        });
        this.onUpdate(); // load images

        this._loadImages(icons);
      }
    }
  }, {
    key: "_loadImages",
    value: function _loadImages(icons) {
      var _this2 = this;

      var ctx = this._canvas.getContext('2d');

      var canvasHeight = this._texture.height;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        var _loop = function _loop() {
          var icon = _step2.value;
          loadImages({
            urls: [icon.url]
          }).then(function (_ref7) {
            var _parameters2;

            var _ref8 = _slicedToArray(_ref7, 1),
                imageData = _ref8[0];

            var iconMapping = _this2._mapping[icon.url];
            var x = iconMapping.x,
                y = iconMapping.y,
                width = iconMapping.width,
                height = iconMapping.height;
            var data = resizeImage(ctx, imageData, width, height);

            _this2._texture.setSubImageData({
              data: data,
              x: x,
              y: canvasHeight - y - height,
              // flip Y as texture stored as reversed Y
              width: width,
              height: height,
              parameters: (_parameters2 = {}, _defineProperty(_parameters2, GL.TEXTURE_MIN_FILTER, DEFAULT_TEXTURE_MIN_FILTER), _defineProperty(_parameters2, GL.TEXTURE_MAG_FILTER, DEFAULT_TEXTURE_MAG_FILTER), _defineProperty(_parameters2, GL.UNPACK_FLIP_Y_WEBGL, true), _parameters2)
            }); // Call to regenerate mipmaps after modifying texture(s)


            _this2._texture.generateMipmap();

            _this2.onUpdate();
          });
        };

        for (var _iterator2 = icons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);

  return IconManager;
}();

export { IconManager as default };
//# sourceMappingURL=icon-manager.js.map
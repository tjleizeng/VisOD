function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* global document */
import { Texture2D } from 'luma.gl';
import TinySDF from '@mapbox/tiny-sdf';
var GL_TEXTURE_WRAP_S = 0x2802;
var GL_TEXTURE_WRAP_T = 0x2803;
var GL_CLAMP_TO_EDGE = 0x812f;
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;

function getDefaultCharacterSet() {
  var charSet = [];

  for (var i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }

  return charSet;
}

export var DEFAULT_CHAR_SET = getDefaultCharacterSet();
export var DEFAULT_FONT_FAMILY = 'Monaco, monospace';
export var DEFAULT_FONT_WEIGHT = 'normal';
export var DEFAULT_FONT_SETTINGS = {
  fontSize: 64,
  buffer: 2,
  sdf: false,
  cutoff: 0.25,
  radius: 3
};

function populateAlphaChannel(alphaChannel, imageData) {
  // populate distance value from tinySDF to image alpha channel
  for (var i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}

function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = '#000';
  ctx.textBaseline = 'baseline';
  ctx.textAlign = 'left';
}

function buildMapping(_ref) {
  var ctx = _ref.ctx,
      fontHeight = _ref.fontHeight,
      buffer = _ref.buffer,
      characterSet = _ref.characterSet,
      maxCanvasWidth = _ref.maxCanvasWidth;
  var mapping = {};
  var row = 0;
  var x = 0;
  Array.from(characterSet).forEach(function (char) {
    // measure texts
    // TODO - use Advanced text metrics when they are adopted:
    // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics
    var _ctx$measureText = ctx.measureText(char),
        width = _ctx$measureText.width;

    if (x + width + buffer * 2 > maxCanvasWidth) {
      x = 0;
      row++;
    }

    mapping[char] = {
      x: x + buffer,
      y: row * (fontHeight + buffer * 2) + buffer,
      width: width,
      height: fontHeight,
      mask: true
    };
    x += width + buffer * 2;
  });
  var canvasHeight = (row + 1) * (fontHeight + buffer * 2);
  return {
    mapping: mapping,
    canvasHeight: canvasHeight
  };
}

export function makeFontAtlas(gl, fontSettings) {
  var _parameters;

  var mergedFontSettings = Object.assign({
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: DEFAULT_FONT_WEIGHT,
    characterSet: DEFAULT_CHAR_SET
  }, DEFAULT_FONT_SETTINGS, fontSettings);
  var fontFamily = mergedFontSettings.fontFamily,
      fontWeight = mergedFontSettings.fontWeight,
      characterSet = mergedFontSettings.characterSet,
      fontSize = mergedFontSettings.fontSize,
      buffer = mergedFontSettings.buffer,
      sdf = mergedFontSettings.sdf,
      radius = mergedFontSettings.radius,
      cutoff = mergedFontSettings.cutoff;
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d'); // build mapping

  setTextStyle(ctx, fontFamily, fontSize, fontWeight);
  var fontHeight = fontSize * HEIGHT_SCALE;

  var _buildMapping = buildMapping({
    ctx: ctx,
    fontHeight: fontHeight,
    buffer: buffer,
    characterSet: characterSet,
    maxCanvasWidth: MAX_CANVAS_WIDTH
  }),
      canvasHeight = _buildMapping.canvasHeight,
      mapping = _buildMapping.mapping;

  canvas.width = MAX_CANVAS_WIDTH;
  canvas.height = canvasHeight;
  setTextStyle(ctx, fontFamily, fontSize, fontWeight); // layout characters

  if (sdf) {
    var tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight); // used to store distance values from tinySDF

    var imageData = ctx.createImageData(tinySDF.size, tinySDF.size);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = characterSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var char = _step.value;
        populateAlphaChannel(tinySDF.draw(char), imageData);
        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y - buffer);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = characterSet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _char = _step2.value;
        ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  return {
    scale: HEIGHT_SCALE,
    mapping: mapping,
    texture: new Texture2D(gl, {
      pixels: canvas,
      // padding is added only between the characters but not for borders
      // enforce CLAMP_TO_EDGE to avoid any artifacts.
      parameters: (_parameters = {}, _defineProperty(_parameters, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE), _defineProperty(_parameters, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE), _parameters)
    })
  };
}
//# sourceMappingURL=font-atlas.js.map
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCode = getCode;
exports.getVertices = getVertices;
exports.CONTOUR_TYPE = void 0;

var _core = require("@deck.gl/core");

var _marchingSquaresCodes = require("./marching-squares-codes");

// All utility mehtods needed to implement Marching Squres algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares
var CONTOUR_TYPE = {
  ISO_LINES: 1,
  ISO_BANDS: 2
};
exports.CONTOUR_TYPE = CONTOUR_TYPE;
var Z_OFFSET = 0.002;
var DEFAULT_THRESHOLD_DATA = {
  zIndex: 0,
  zOffsetScale: 1
}; // Utility methods

function getVertexCode(weight, threshold) {
  // threshold must be a single value or a range (array of size 2)
  // Iso-bands
  if (Array.isArray(threshold)) {
    if (weight < threshold[0]) {
      return 0;
    }

    return weight < threshold[1] ? 1 : 2;
  } // Iso-lines


  return weight >= threshold ? 1 : 0;
} // Returns marching square code for given cell

/* eslint-disable complexity, max-statements*/


function getCode(opts) {
  // Assumptions
  // Origin is on bottom-left , and X increase to right, Y to top
  // When processing one cell, we process 4 cells, by extending row to top and on column to right
  // to create a 2X2 cell grid
  var cellWeights = opts.cellWeights,
      x = opts.x,
      y = opts.y,
      width = opts.width,
      height = opts.height;
  var threshold = opts.threshold;

  if (opts.thresholdValue) {
    _core.log.deprecated('thresholdValue', 'threshold')();

    threshold = opts.thresholdValue;
  }

  var isLeftBoundary = x < 0;
  var isRightBoundary = x >= width - 1;
  var isBottomBoundary = y < 0;
  var isTopBoundary = y >= height - 1;
  var isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;
  var weights = {};
  var codes = {}; // TOP

  if (isLeftBoundary || isTopBoundary) {
    codes.top = 0;
  } else {
    weights.top = cellWeights[(y + 1) * width + x];
    codes.top = getVertexCode(weights.top, threshold);
  } // TOP-RIGHT


  if (isRightBoundary || isTopBoundary) {
    codes.topRight = 0;
  } else {
    weights.topRight = cellWeights[(y + 1) * width + x + 1];
    codes.topRight = getVertexCode(weights.topRight, threshold);
  } // RIGHT


  if (isRightBoundary || isBottomBoundary) {
    codes.right = 0;
  } else {
    weights.right = cellWeights[y * width + x + 1];
    codes.right = getVertexCode(weights.right, threshold);
  } // CURRENT


  if (isLeftBoundary || isBottomBoundary) {
    codes.current = 0;
  } else {
    weights.current = cellWeights[y * width + x];
    codes.current = getVertexCode(weights.current, threshold);
  }

  var top = codes.top,
      topRight = codes.topRight,
      right = codes.right,
      current = codes.current;
  var code = -1;

  if (Number.isFinite(threshold)) {
    code = top << 3 | topRight << 2 | right << 1 | current;
  }

  if (Array.isArray(threshold)) {
    code = top << 6 | topRight << 4 | right << 2 | current;
  }

  var meanCode = 0; // meanCode is only needed for saddle cases, and they should
  // only occur when we are not processing a cell on boundary
  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes

  if (!isBoundary) {
    meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold);
  }

  return {
    code: code,
    meanCode: meanCode
  };
}
/* eslint-enable complexity, max-statements*/
// Returns intersection vertices for given cellindex
// [x, y] refers current marchng cell, reference vertex is always top-right corner


function getVertices(opts) {
  var gridOrigin = opts.gridOrigin,
      cellSize = opts.cellSize,
      x = opts.x,
      y = opts.y,
      code = opts.code,
      meanCode = opts.meanCode,
      _opts$type = opts.type,
      type = _opts$type === void 0 ? CONTOUR_TYPE.ISO_LINES : _opts$type;
  var thresholdData = Object.assign({}, DEFAULT_THRESHOLD_DATA, opts.thresholdData);
  var offsets = type === CONTOUR_TYPE.ISO_BANDS ? _marchingSquaresCodes.ISOBANDS_CODE_OFFSET_MAP[code] : _marchingSquaresCodes.ISOLINES_CODE_OFFSET_MAP[code]; // handle saddle cases

  if (!Array.isArray(offsets)) {
    offsets = offsets[meanCode];
  } // Reference vertex is at top-right move to top-right corner


  var vZ = thresholdData.zIndex * Z_OFFSET * thresholdData.zOffsetScale;
  var rX = (x + 1) * cellSize[0];
  var rY = (y + 1) * cellSize[1];
  var refVertexX = gridOrigin[0] + rX;
  var refVertexY = gridOrigin[1] + rY; // offsets format
  // ISO_LINES: [[1A, 1B], [2A, 2B]],
  // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],
  // vertices format
  // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],
  // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format
  //      [
  //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],
  //        ...
  //      ]

  if (type === CONTOUR_TYPE.ISO_BANDS) {
    var polygons = [];
    offsets.forEach(function (polygonOffsets) {
      var polygon = [];
      polygonOffsets.forEach(function (xyOffset) {
        var vX = refVertexX + xyOffset[0] * cellSize[0];
        var vY = refVertexY + xyOffset[1] * cellSize[1];
        polygon.push([vX, vY, vZ]);
      });
      polygons.push(polygon);
    });
    return polygons;
  } // default case is ISO_LINES


  var lines = [];
  offsets.forEach(function (xyOffsets) {
    xyOffsets.forEach(function (offset) {
      var vX = refVertexX + offset[0] * cellSize[0];
      var vY = refVertexY + offset[1] * cellSize[1];
      lines.push([vX, vY, vZ]);
    });
  });
  return lines;
}
//# sourceMappingURL=marching-squares.js.map
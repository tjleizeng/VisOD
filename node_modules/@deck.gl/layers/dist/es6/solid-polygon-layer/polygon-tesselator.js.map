{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"names":["Polygon","experimental","Tesselator","fp64","fp64Module","fp64LowPart","colorArray","PolygonTesselator","constructor","data","getGeometry","positionFormat","IndexType","Uint32Array","attributes","positions","size","positions64xyLow","fp64Only","vertexValid","type","Uint8ClampedArray","indices","get","attributeName","target","accessor","subarray","vertexCount","_updateAttribute","getValue","object","color","length","index","getGeometrySize","polygon","getVertexCount","positionSize","updateGeometryAttributes","context","normalize","geometrySize","_updateIndices","_updatePositions","geometryIndex","offset","vertexStart","indexStart","indexLayout","typedArrayManager","currentLength","i","getSurfaceIndices","allocate","copy","j","polygonPositions","holeIndices","x","y","z"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {experimental} from '@deck.gl/core';\nconst {Tesselator} = experimental;\nimport {fp64 as fp64Module} from 'luma.gl';\nconst {fp64LowPart} = fp64Module;\n\n// colorArray is used to copy over color values if the passed color is an RGB\n// array instead of RGBA\nconst colorArray = [0, 0, 0, 255];\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor({data, getGeometry, fp64, positionFormat, IndexType = Uint32Array}) {\n    super({\n      data,\n      getGeometry,\n      fp64,\n      positionFormat,\n      attributes: {\n        positions: {size: 3},\n        positions64xyLow: {size: 2, fp64Only: true},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName, target, accessor) {\n    if (attributeName === 'indices') {\n      return this.attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    if (this.attributes[attributeName]) {\n      return this.attributes[attributeName];\n    }\n\n    switch (attributeName) {\n      case 'elevations':\n        return this._updateAttribute({\n          target,\n          size: 1,\n          getValue: object => [accessor(object)]\n        });\n\n      case 'colors':\n        return this._updateAttribute({\n          target,\n          size: 4,\n          getValue: object => {\n            const color = accessor(object);\n            if (color.length === 4) {\n              return color;\n            }\n            colorArray[0] = color[0];\n            colorArray[1] = color[1];\n            colorArray[2] = color[2];\n            return colorArray;\n          }\n        });\n\n      case 'pickingColors':\n        return this._updateAttribute({\n          target,\n          size: 3,\n          getValue: (object, index) => accessor(index)\n        });\n\n      default:\n        return null;\n    }\n  }\n\n  /* Implement base Tesselator interface */\n  getGeometrySize(polygon) {\n    return Polygon.getVertexCount(polygon, this.positionSize);\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    polygon = Polygon.normalize(polygon, this.positionSize, context.geometrySize);\n\n    this._updateIndices(polygon, context);\n    this._updatePositions(polygon, context);\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexLayout, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    let currentLength = target.length;\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize);\n\n    // make sure the buffer is large enough\n    if (currentLength < i + indices.length) {\n      currentLength = (i + indices.length) * 2;\n      target = typedArrayManager.allocate(target, currentLength, {\n        type: target.constructor,\n        size: 1,\n        copy: true\n      });\n    }\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexLayout[geometryIndex] = indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions, positions64xyLow, vertexValid},\n      fp64,\n      positionSize\n    } = this;\n\n    let i = vertexStart;\n    const {positions: polygonPositions, holeIndices} = polygon;\n\n    for (let j = 0; j < geometrySize; j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n      if (fp64) {\n        positions64xyLow[i * 2] = fp64LowPart(x);\n        positions64xyLow[i * 2 + 1] = fp64LowPart(y);\n      }\n      vertexValid[i] = 1;\n      i++;\n    }\n\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n"],"file":"polygon-tesselator.js"}